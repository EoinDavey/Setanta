/* AutoGenerated Code, changes may be overwritten
* INPUT GRAMMAR:
* Program     := stmts=AsgnStmt* _
* AsgnStmt    := IfStmt
*              | BlockStmt
*              | NuairStmt
*              | LeStmt
*              | CCStmt
*              | BrisStmt
*              | CtlchStmt
*              | GniomhStmt
*              | ToradhStmt
*              | AssgnStmt
*              | DefnStmt
*              | Expr
* NonAsgnStmt := IfStmt
*              | NuairStmt
*              | LeStmt
*              | CCStmt
*              | BrisStmt
*              | CtlchStmt
*              | ToradhStmt
*              | BlockStmt
*              | AssgnStmt
*              | Expr
* IfStmt      := _ 'm[áa]' &gap expr=Expr &gap stmt=NonAsgnStmt elsebranch={_ 'n[oó]' &gap stmt=NonAsgnStmt}?
* BlockStmt   := _ '{' blk=AsgnStmt* _ '}'
* NuairStmt   := _ 'nuair' gap 'a' expr=Expr &gap stmt=NonAsgnStmt
* LeStmt      := _ 'le' &gap id=ID _ 'idir' _ '\('strt=Expr _ ',' end=Expr _ '\)' stmt=NonAsgnStmt
* DefnStmt    := _ id=ID _ ':=' _ expr=Expr
* AssgnStmt   := _ id=LSpec _ '=' _ expr=Expr
* GniomhStmt  := _ 'gn[íi]omh' &gap id=ID _ '\(' args=CSIDs? _ '\)' _ '{'
*     stmts=AsgnStmt*
* _ '}'
* CtlchStmt   := _ 'creatlach' &gap id=ID _ '{'
*     gniomhs=GniomhStmt*
* _ '}'
* BrisStmt    := _ 'bris'
* CCStmt      := _ 'chun\s+cinn'
* ToradhStmt  := _ 'toradh' &gap exp=Expr?
* Expr        := And
* And         := head=Or tail={_ '\&' trm=Or}*
* Or          := head=Eq tail={_ '\|' trm=Eq}*
* Eq          := head=Comp tail={_ op='[!=]=' trm=Comp}*
* Comp        := head=Sum tail={_ op=Compare trm=Sum}*
* Sum         := head=Product tail={_ op=PlusMinus trm=Product}*
* Product     := head=Prefix tail={_ op=MulDiv trm=Prefix}*
* Prefix      := _ op='-|!'? pf=Postfix
* Postfix     := at=ObjLookups ops=PostOp*
* PostOp      := '\(' args=CSArgs? _ '\)' | '\[' expr=Expr '\]'
* Atom        :=  _ '\(' trm=Expr '\)'
*              | ID
*              | Litreacha
*              | Int
*              | Bool
*              | Neamhni
*              | ListLit
* LSpec       := id=ID ops=PostOp*
* CSArgs      := head=Expr tail={_ ',' exp=Expr}*
* CSIDs       := head=ID tail={_ ',' id=ID}*
* ListLit     := _ '\[' els=CSArgs? _ '\]'
* PlusMinus   := '\+|-'
* MulDiv      := '\*|\/|%'
* Compare     := '(<=)|(>=)|<|>'
* Keyword     := 'm[áa]' | 'n[oó]' | 'nuair\s+a' | 'f[ií]or|breag'
*     | 'gn[ií]omh' | 'chun\s+cinn' | 'neamhn[ií]' | 'toradh' | 'creatlach'
* ID          := _ !{Keyword gap} id='[a-zA-Z_áéíóúÁÉÍÓÚ]+'
* Bool        := _ bool='f[ií]or|breag'
* Neamhni     := _ 'neamhn[ií]'
* Int         := _ int='-?[0-9]+'
* Litreacha   := _ '\'' val='([^\'\\]|(\\.))*' '\''
* ObjLookups  := _ attrs={id=ID '@' !wspace}* root=Atom
* _           := wspace*
* wspace      := '(?:\s|>--(?:(?!--<).)*(--<|\n))'
* gap         := { wspace | '[^a-zA-Z0-9áéíóúÁÉÍÓÚ]' }+ | '$'
*/
type Nullable<T> = T | null;
type $$RuleType<T> = (log?: (msg: string) => void) => Nullable<T>;
export interface ContextRecorder {
    record(pos: PosInfo, depth: number, result: any, negating: boolean, extraInfo: string[]): void;
}
interface ASTNodeIntf {
    kind: ASTKinds;
}
export enum ASTKinds {
    Program,
    AsgnStmt_1,
    AsgnStmt_2,
    AsgnStmt_3,
    AsgnStmt_4,
    AsgnStmt_5,
    AsgnStmt_6,
    AsgnStmt_7,
    AsgnStmt_8,
    AsgnStmt_9,
    AsgnStmt_10,
    AsgnStmt_11,
    AsgnStmt_12,
    NonAsgnStmt_1,
    NonAsgnStmt_2,
    NonAsgnStmt_3,
    NonAsgnStmt_4,
    NonAsgnStmt_5,
    NonAsgnStmt_6,
    NonAsgnStmt_7,
    NonAsgnStmt_8,
    NonAsgnStmt_9,
    NonAsgnStmt_10,
    IfStmt,
    IfStmt_$0,
    BlockStmt,
    NuairStmt,
    LeStmt,
    DefnStmt,
    AssgnStmt,
    GniomhStmt,
    CtlchStmt,
    BrisStmt,
    CCStmt,
    ToradhStmt,
    Expr,
    And,
    And_$0,
    Or,
    Or_$0,
    Eq,
    Eq_$0,
    Comp,
    Comp_$0,
    Sum,
    Sum_$0,
    Product,
    Product_$0,
    Prefix,
    Postfix,
    PostOp_1,
    PostOp_2,
    Atom_1,
    Atom_2,
    Atom_3,
    Atom_4,
    Atom_5,
    Atom_6,
    Atom_7,
    LSpec,
    CSArgs,
    CSArgs_$0,
    CSIDs,
    CSIDs_$0,
    ListLit,
    PlusMinus,
    MulDiv,
    Compare,
    Keyword_1,
    Keyword_2,
    Keyword_3,
    Keyword_4,
    Keyword_5,
    Keyword_6,
    Keyword_7,
    Keyword_8,
    Keyword_9,
    ID,
    ID_$0,
    Bool,
    Neamhni,
    Int,
    Litreacha,
    ObjLookups,
    ObjLookups_$0,
    _,
    wspace,
    gap_1,
    gap_2,
    gap_$0_1,
    gap_$0_2,
}
export interface Program {
    kind: ASTKinds.Program;
    stmts: AsgnStmt[];
}
export type AsgnStmt = AsgnStmt_1 | AsgnStmt_2 | AsgnStmt_3 | AsgnStmt_4 | AsgnStmt_5 | AsgnStmt_6 | AsgnStmt_7 | AsgnStmt_8 | AsgnStmt_9 | AsgnStmt_10 | AsgnStmt_11 | AsgnStmt_12;
export type AsgnStmt_1 = IfStmt;
export type AsgnStmt_2 = BlockStmt;
export type AsgnStmt_3 = NuairStmt;
export type AsgnStmt_4 = LeStmt;
export type AsgnStmt_5 = CCStmt;
export type AsgnStmt_6 = BrisStmt;
export type AsgnStmt_7 = CtlchStmt;
export type AsgnStmt_8 = GniomhStmt;
export type AsgnStmt_9 = ToradhStmt;
export type AsgnStmt_10 = AssgnStmt;
export type AsgnStmt_11 = DefnStmt;
export type AsgnStmt_12 = Expr;
export type NonAsgnStmt = NonAsgnStmt_1 | NonAsgnStmt_2 | NonAsgnStmt_3 | NonAsgnStmt_4 | NonAsgnStmt_5 | NonAsgnStmt_6 | NonAsgnStmt_7 | NonAsgnStmt_8 | NonAsgnStmt_9 | NonAsgnStmt_10;
export type NonAsgnStmt_1 = IfStmt;
export type NonAsgnStmt_2 = NuairStmt;
export type NonAsgnStmt_3 = LeStmt;
export type NonAsgnStmt_4 = CCStmt;
export type NonAsgnStmt_5 = BrisStmt;
export type NonAsgnStmt_6 = CtlchStmt;
export type NonAsgnStmt_7 = ToradhStmt;
export type NonAsgnStmt_8 = BlockStmt;
export type NonAsgnStmt_9 = AssgnStmt;
export type NonAsgnStmt_10 = Expr;
export interface IfStmt {
    kind: ASTKinds.IfStmt;
    expr: Expr;
    stmt: NonAsgnStmt;
    elsebranch: Nullable<IfStmt_$0>;
}
export interface IfStmt_$0 {
    kind: ASTKinds.IfStmt_$0;
    stmt: NonAsgnStmt;
}
export interface BlockStmt {
    kind: ASTKinds.BlockStmt;
    blk: AsgnStmt[];
}
export interface NuairStmt {
    kind: ASTKinds.NuairStmt;
    expr: Expr;
    stmt: NonAsgnStmt;
}
export interface LeStmt {
    kind: ASTKinds.LeStmt;
    id: ID;
    strt: Expr;
    end: Expr;
    stmt: NonAsgnStmt;
}
export interface DefnStmt {
    kind: ASTKinds.DefnStmt;
    id: ID;
    expr: Expr;
}
export interface AssgnStmt {
    kind: ASTKinds.AssgnStmt;
    id: LSpec;
    expr: Expr;
}
export interface GniomhStmt {
    kind: ASTKinds.GniomhStmt;
    id: ID;
    args: Nullable<CSIDs>;
    stmts: AsgnStmt[];
}
export interface CtlchStmt {
    kind: ASTKinds.CtlchStmt;
    id: ID;
    gniomhs: GniomhStmt[];
}
export interface BrisStmt {
    kind: ASTKinds.BrisStmt;
}
export interface CCStmt {
    kind: ASTKinds.CCStmt;
}
export interface ToradhStmt {
    kind: ASTKinds.ToradhStmt;
    exp: Nullable<Expr>;
}
export type Expr = And;
export interface And {
    kind: ASTKinds.And;
    head: Or;
    tail: And_$0[];
}
export interface And_$0 {
    kind: ASTKinds.And_$0;
    trm: Or;
}
export interface Or {
    kind: ASTKinds.Or;
    head: Eq;
    tail: Or_$0[];
}
export interface Or_$0 {
    kind: ASTKinds.Or_$0;
    trm: Eq;
}
export interface Eq {
    kind: ASTKinds.Eq;
    head: Comp;
    tail: Eq_$0[];
}
export interface Eq_$0 {
    kind: ASTKinds.Eq_$0;
    op: string;
    trm: Comp;
}
export interface Comp {
    kind: ASTKinds.Comp;
    head: Sum;
    tail: Comp_$0[];
}
export interface Comp_$0 {
    kind: ASTKinds.Comp_$0;
    op: Compare;
    trm: Sum;
}
export interface Sum {
    kind: ASTKinds.Sum;
    head: Product;
    tail: Sum_$0[];
}
export interface Sum_$0 {
    kind: ASTKinds.Sum_$0;
    op: PlusMinus;
    trm: Product;
}
export interface Product {
    kind: ASTKinds.Product;
    head: Prefix;
    tail: Product_$0[];
}
export interface Product_$0 {
    kind: ASTKinds.Product_$0;
    op: MulDiv;
    trm: Prefix;
}
export interface Prefix {
    kind: ASTKinds.Prefix;
    op: Nullable<string>;
    pf: Postfix;
}
export interface Postfix {
    kind: ASTKinds.Postfix;
    at: ObjLookups;
    ops: PostOp[];
}
export type PostOp = PostOp_1 | PostOp_2;
export interface PostOp_1 {
    kind: ASTKinds.PostOp_1;
    args: Nullable<CSArgs>;
}
export interface PostOp_2 {
    kind: ASTKinds.PostOp_2;
    expr: Expr;
}
export type Atom = Atom_1 | Atom_2 | Atom_3 | Atom_4 | Atom_5 | Atom_6 | Atom_7;
export interface Atom_1 {
    kind: ASTKinds.Atom_1;
    trm: Expr;
}
export type Atom_2 = ID;
export type Atom_3 = Litreacha;
export type Atom_4 = Int;
export type Atom_5 = Bool;
export type Atom_6 = Neamhni;
export type Atom_7 = ListLit;
export interface LSpec {
    kind: ASTKinds.LSpec;
    id: ID;
    ops: PostOp[];
}
export interface CSArgs {
    kind: ASTKinds.CSArgs;
    head: Expr;
    tail: CSArgs_$0[];
}
export interface CSArgs_$0 {
    kind: ASTKinds.CSArgs_$0;
    exp: Expr;
}
export interface CSIDs {
    kind: ASTKinds.CSIDs;
    head: ID;
    tail: CSIDs_$0[];
}
export interface CSIDs_$0 {
    kind: ASTKinds.CSIDs_$0;
    id: ID;
}
export interface ListLit {
    kind: ASTKinds.ListLit;
    els: Nullable<CSArgs>;
}
export type PlusMinus = string;
export type MulDiv = string;
export type Compare = string;
export type Keyword = Keyword_1 | Keyword_2 | Keyword_3 | Keyword_4 | Keyword_5 | Keyword_6 | Keyword_7 | Keyword_8 | Keyword_9;
export type Keyword_1 = string;
export type Keyword_2 = string;
export type Keyword_3 = string;
export type Keyword_4 = string;
export type Keyword_5 = string;
export type Keyword_6 = string;
export type Keyword_7 = string;
export type Keyword_8 = string;
export type Keyword_9 = string;
export interface ID {
    kind: ASTKinds.ID;
    id: string;
}
export interface ID_$0 {
    kind: ASTKinds.ID_$0;
}
export interface Bool {
    kind: ASTKinds.Bool;
    bool: string;
}
export interface Neamhni {
    kind: ASTKinds.Neamhni;
}
export interface Int {
    kind: ASTKinds.Int;
    int: string;
}
export interface Litreacha {
    kind: ASTKinds.Litreacha;
    val: string;
}
export interface ObjLookups {
    kind: ASTKinds.ObjLookups;
    attrs: ObjLookups_$0[];
    root: Atom;
}
export interface ObjLookups_$0 {
    kind: ASTKinds.ObjLookups_$0;
    id: ID;
}
export type _ = wspace[];
export type wspace = string;
export type gap = gap_1 | gap_2;
export type gap_1 = gap_$0[];
export type gap_2 = string;
export type gap_$0 = gap_$0_1 | gap_$0_2;
export type gap_$0_1 = wspace;
export type gap_$0_2 = string;
export class Parser {
    private readonly input: string;
    private pos: PosInfo;
    private negating: boolean = false;
    constructor(input: string) {
        this.pos = new PosInfo(0, 1, 0);
        this.input = input;
    }
    public reset(pos: PosInfo) {
        this.pos = pos;
    }
    public finished(): boolean {
        return this.pos.overallPos === this.input.length;
    }
    public matchProgram($$dpth: number, cr?: ContextRecorder): Nullable<Program> {
        return this.runner<Program>($$dpth,
            (log) => {
                if (log) {
                    log("Program");
                }
                let stmts: Nullable<AsgnStmt[]>;
                let res: Nullable<Program> = null;
                if (true
                    && (stmts = this.loop<AsgnStmt>(() => this.matchAsgnStmt($$dpth + 1, cr), true)) !== null
                    && this.match_($$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.Program, stmts};
                }
                return res;
            }, cr)();
    }
    public matchAsgnStmt($$dpth: number, cr?: ContextRecorder): Nullable<AsgnStmt> {
        return this.choice<AsgnStmt>([
            () => this.matchAsgnStmt_1($$dpth + 1, cr),
            () => this.matchAsgnStmt_2($$dpth + 1, cr),
            () => this.matchAsgnStmt_3($$dpth + 1, cr),
            () => this.matchAsgnStmt_4($$dpth + 1, cr),
            () => this.matchAsgnStmt_5($$dpth + 1, cr),
            () => this.matchAsgnStmt_6($$dpth + 1, cr),
            () => this.matchAsgnStmt_7($$dpth + 1, cr),
            () => this.matchAsgnStmt_8($$dpth + 1, cr),
            () => this.matchAsgnStmt_9($$dpth + 1, cr),
            () => this.matchAsgnStmt_10($$dpth + 1, cr),
            () => this.matchAsgnStmt_11($$dpth + 1, cr),
            () => this.matchAsgnStmt_12($$dpth + 1, cr),
        ]);
    }
    public matchAsgnStmt_1($$dpth: number, cr?: ContextRecorder): Nullable<AsgnStmt_1> {
        return this.matchIfStmt($$dpth + 1, cr);
    }
    public matchAsgnStmt_2($$dpth: number, cr?: ContextRecorder): Nullable<AsgnStmt_2> {
        return this.matchBlockStmt($$dpth + 1, cr);
    }
    public matchAsgnStmt_3($$dpth: number, cr?: ContextRecorder): Nullable<AsgnStmt_3> {
        return this.matchNuairStmt($$dpth + 1, cr);
    }
    public matchAsgnStmt_4($$dpth: number, cr?: ContextRecorder): Nullable<AsgnStmt_4> {
        return this.matchLeStmt($$dpth + 1, cr);
    }
    public matchAsgnStmt_5($$dpth: number, cr?: ContextRecorder): Nullable<AsgnStmt_5> {
        return this.matchCCStmt($$dpth + 1, cr);
    }
    public matchAsgnStmt_6($$dpth: number, cr?: ContextRecorder): Nullable<AsgnStmt_6> {
        return this.matchBrisStmt($$dpth + 1, cr);
    }
    public matchAsgnStmt_7($$dpth: number, cr?: ContextRecorder): Nullable<AsgnStmt_7> {
        return this.matchCtlchStmt($$dpth + 1, cr);
    }
    public matchAsgnStmt_8($$dpth: number, cr?: ContextRecorder): Nullable<AsgnStmt_8> {
        return this.matchGniomhStmt($$dpth + 1, cr);
    }
    public matchAsgnStmt_9($$dpth: number, cr?: ContextRecorder): Nullable<AsgnStmt_9> {
        return this.matchToradhStmt($$dpth + 1, cr);
    }
    public matchAsgnStmt_10($$dpth: number, cr?: ContextRecorder): Nullable<AsgnStmt_10> {
        return this.matchAssgnStmt($$dpth + 1, cr);
    }
    public matchAsgnStmt_11($$dpth: number, cr?: ContextRecorder): Nullable<AsgnStmt_11> {
        return this.matchDefnStmt($$dpth + 1, cr);
    }
    public matchAsgnStmt_12($$dpth: number, cr?: ContextRecorder): Nullable<AsgnStmt_12> {
        return this.matchExpr($$dpth + 1, cr);
    }
    public matchNonAsgnStmt($$dpth: number, cr?: ContextRecorder): Nullable<NonAsgnStmt> {
        return this.choice<NonAsgnStmt>([
            () => this.matchNonAsgnStmt_1($$dpth + 1, cr),
            () => this.matchNonAsgnStmt_2($$dpth + 1, cr),
            () => this.matchNonAsgnStmt_3($$dpth + 1, cr),
            () => this.matchNonAsgnStmt_4($$dpth + 1, cr),
            () => this.matchNonAsgnStmt_5($$dpth + 1, cr),
            () => this.matchNonAsgnStmt_6($$dpth + 1, cr),
            () => this.matchNonAsgnStmt_7($$dpth + 1, cr),
            () => this.matchNonAsgnStmt_8($$dpth + 1, cr),
            () => this.matchNonAsgnStmt_9($$dpth + 1, cr),
            () => this.matchNonAsgnStmt_10($$dpth + 1, cr),
        ]);
    }
    public matchNonAsgnStmt_1($$dpth: number, cr?: ContextRecorder): Nullable<NonAsgnStmt_1> {
        return this.matchIfStmt($$dpth + 1, cr);
    }
    public matchNonAsgnStmt_2($$dpth: number, cr?: ContextRecorder): Nullable<NonAsgnStmt_2> {
        return this.matchNuairStmt($$dpth + 1, cr);
    }
    public matchNonAsgnStmt_3($$dpth: number, cr?: ContextRecorder): Nullable<NonAsgnStmt_3> {
        return this.matchLeStmt($$dpth + 1, cr);
    }
    public matchNonAsgnStmt_4($$dpth: number, cr?: ContextRecorder): Nullable<NonAsgnStmt_4> {
        return this.matchCCStmt($$dpth + 1, cr);
    }
    public matchNonAsgnStmt_5($$dpth: number, cr?: ContextRecorder): Nullable<NonAsgnStmt_5> {
        return this.matchBrisStmt($$dpth + 1, cr);
    }
    public matchNonAsgnStmt_6($$dpth: number, cr?: ContextRecorder): Nullable<NonAsgnStmt_6> {
        return this.matchCtlchStmt($$dpth + 1, cr);
    }
    public matchNonAsgnStmt_7($$dpth: number, cr?: ContextRecorder): Nullable<NonAsgnStmt_7> {
        return this.matchToradhStmt($$dpth + 1, cr);
    }
    public matchNonAsgnStmt_8($$dpth: number, cr?: ContextRecorder): Nullable<NonAsgnStmt_8> {
        return this.matchBlockStmt($$dpth + 1, cr);
    }
    public matchNonAsgnStmt_9($$dpth: number, cr?: ContextRecorder): Nullable<NonAsgnStmt_9> {
        return this.matchAssgnStmt($$dpth + 1, cr);
    }
    public matchNonAsgnStmt_10($$dpth: number, cr?: ContextRecorder): Nullable<NonAsgnStmt_10> {
        return this.matchExpr($$dpth + 1, cr);
    }
    public matchIfStmt($$dpth: number, cr?: ContextRecorder): Nullable<IfStmt> {
        return this.runner<IfStmt>($$dpth,
            (log) => {
                if (log) {
                    log("IfStmt");
                }
                let expr: Nullable<Expr>;
                let stmt: Nullable<NonAsgnStmt>;
                let elsebranch: Nullable<Nullable<IfStmt_$0>>;
                let res: Nullable<IfStmt> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`m[áa]`, $$dpth + 1, cr) !== null
                    && this.noConsume<gap>(() => this.matchgap($$dpth + 1, cr)) !== null
                    && (expr = this.matchExpr($$dpth + 1, cr)) !== null
                    && this.noConsume<gap>(() => this.matchgap($$dpth + 1, cr)) !== null
                    && (stmt = this.matchNonAsgnStmt($$dpth + 1, cr)) !== null
                    && ((elsebranch = this.matchIfStmt_$0($$dpth + 1, cr)) || true)
                ) {
                    res = {kind: ASTKinds.IfStmt, expr, stmt, elsebranch};
                }
                return res;
            }, cr)();
    }
    public matchIfStmt_$0($$dpth: number, cr?: ContextRecorder): Nullable<IfStmt_$0> {
        return this.runner<IfStmt_$0>($$dpth,
            (log) => {
                if (log) {
                    log("IfStmt_$0");
                }
                let stmt: Nullable<NonAsgnStmt>;
                let res: Nullable<IfStmt_$0> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`n[oó]`, $$dpth + 1, cr) !== null
                    && this.noConsume<gap>(() => this.matchgap($$dpth + 1, cr)) !== null
                    && (stmt = this.matchNonAsgnStmt($$dpth + 1, cr)) !== null
                ) {
                    res = {kind: ASTKinds.IfStmt_$0, stmt};
                }
                return res;
            }, cr)();
    }
    public matchBlockStmt($$dpth: number, cr?: ContextRecorder): Nullable<BlockStmt> {
        return this.runner<BlockStmt>($$dpth,
            (log) => {
                if (log) {
                    log("BlockStmt");
                }
                let blk: Nullable<AsgnStmt[]>;
                let res: Nullable<BlockStmt> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`{`, $$dpth + 1, cr) !== null
                    && (blk = this.loop<AsgnStmt>(() => this.matchAsgnStmt($$dpth + 1, cr), true)) !== null
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`}`, $$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.BlockStmt, blk};
                }
                return res;
            }, cr)();
    }
    public matchNuairStmt($$dpth: number, cr?: ContextRecorder): Nullable<NuairStmt> {
        return this.runner<NuairStmt>($$dpth,
            (log) => {
                if (log) {
                    log("NuairStmt");
                }
                let expr: Nullable<Expr>;
                let stmt: Nullable<NonAsgnStmt>;
                let res: Nullable<NuairStmt> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`nuair`, $$dpth + 1, cr) !== null
                    && this.matchgap($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`a`, $$dpth + 1, cr) !== null
                    && (expr = this.matchExpr($$dpth + 1, cr)) !== null
                    && this.noConsume<gap>(() => this.matchgap($$dpth + 1, cr)) !== null
                    && (stmt = this.matchNonAsgnStmt($$dpth + 1, cr)) !== null
                ) {
                    res = {kind: ASTKinds.NuairStmt, expr, stmt};
                }
                return res;
            }, cr)();
    }
    public matchLeStmt($$dpth: number, cr?: ContextRecorder): Nullable<LeStmt> {
        return this.runner<LeStmt>($$dpth,
            (log) => {
                if (log) {
                    log("LeStmt");
                }
                let id: Nullable<ID>;
                let strt: Nullable<Expr>;
                let end: Nullable<Expr>;
                let stmt: Nullable<NonAsgnStmt>;
                let res: Nullable<LeStmt> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`le`, $$dpth + 1, cr) !== null
                    && this.noConsume<gap>(() => this.matchgap($$dpth + 1, cr)) !== null
                    && (id = this.matchID($$dpth + 1, cr)) !== null
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`idir`, $$dpth + 1, cr) !== null
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`\(`, $$dpth + 1, cr) !== null
                    && (strt = this.matchExpr($$dpth + 1, cr)) !== null
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`,`, $$dpth + 1, cr) !== null
                    && (end = this.matchExpr($$dpth + 1, cr)) !== null
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`\)`, $$dpth + 1, cr) !== null
                    && (stmt = this.matchNonAsgnStmt($$dpth + 1, cr)) !== null
                ) {
                    res = {kind: ASTKinds.LeStmt, id, strt, end, stmt};
                }
                return res;
            }, cr)();
    }
    public matchDefnStmt($$dpth: number, cr?: ContextRecorder): Nullable<DefnStmt> {
        return this.runner<DefnStmt>($$dpth,
            (log) => {
                if (log) {
                    log("DefnStmt");
                }
                let id: Nullable<ID>;
                let expr: Nullable<Expr>;
                let res: Nullable<DefnStmt> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && (id = this.matchID($$dpth + 1, cr)) !== null
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`:=`, $$dpth + 1, cr) !== null
                    && this.match_($$dpth + 1, cr) !== null
                    && (expr = this.matchExpr($$dpth + 1, cr)) !== null
                ) {
                    res = {kind: ASTKinds.DefnStmt, id, expr};
                }
                return res;
            }, cr)();
    }
    public matchAssgnStmt($$dpth: number, cr?: ContextRecorder): Nullable<AssgnStmt> {
        return this.runner<AssgnStmt>($$dpth,
            (log) => {
                if (log) {
                    log("AssgnStmt");
                }
                let id: Nullable<LSpec>;
                let expr: Nullable<Expr>;
                let res: Nullable<AssgnStmt> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && (id = this.matchLSpec($$dpth + 1, cr)) !== null
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`=`, $$dpth + 1, cr) !== null
                    && this.match_($$dpth + 1, cr) !== null
                    && (expr = this.matchExpr($$dpth + 1, cr)) !== null
                ) {
                    res = {kind: ASTKinds.AssgnStmt, id, expr};
                }
                return res;
            }, cr)();
    }
    public matchGniomhStmt($$dpth: number, cr?: ContextRecorder): Nullable<GniomhStmt> {
        return this.runner<GniomhStmt>($$dpth,
            (log) => {
                if (log) {
                    log("GniomhStmt");
                }
                let id: Nullable<ID>;
                let args: Nullable<Nullable<CSIDs>>;
                let stmts: Nullable<AsgnStmt[]>;
                let res: Nullable<GniomhStmt> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`gn[íi]omh`, $$dpth + 1, cr) !== null
                    && this.noConsume<gap>(() => this.matchgap($$dpth + 1, cr)) !== null
                    && (id = this.matchID($$dpth + 1, cr)) !== null
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`\(`, $$dpth + 1, cr) !== null
                    && ((args = this.matchCSIDs($$dpth + 1, cr)) || true)
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`\)`, $$dpth + 1, cr) !== null
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`{`, $$dpth + 1, cr) !== null
                    && (stmts = this.loop<AsgnStmt>(() => this.matchAsgnStmt($$dpth + 1, cr), true)) !== null
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`}`, $$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.GniomhStmt, id, args, stmts};
                }
                return res;
            }, cr)();
    }
    public matchCtlchStmt($$dpth: number, cr?: ContextRecorder): Nullable<CtlchStmt> {
        return this.runner<CtlchStmt>($$dpth,
            (log) => {
                if (log) {
                    log("CtlchStmt");
                }
                let id: Nullable<ID>;
                let gniomhs: Nullable<GniomhStmt[]>;
                let res: Nullable<CtlchStmt> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`creatlach`, $$dpth + 1, cr) !== null
                    && this.noConsume<gap>(() => this.matchgap($$dpth + 1, cr)) !== null
                    && (id = this.matchID($$dpth + 1, cr)) !== null
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`{`, $$dpth + 1, cr) !== null
                    && (gniomhs = this.loop<GniomhStmt>(() => this.matchGniomhStmt($$dpth + 1, cr), true)) !== null
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`}`, $$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.CtlchStmt, id, gniomhs};
                }
                return res;
            }, cr)();
    }
    public matchBrisStmt($$dpth: number, cr?: ContextRecorder): Nullable<BrisStmt> {
        return this.runner<BrisStmt>($$dpth,
            (log) => {
                if (log) {
                    log("BrisStmt");
                }
                let res: Nullable<BrisStmt> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`bris`, $$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.BrisStmt, };
                }
                return res;
            }, cr)();
    }
    public matchCCStmt($$dpth: number, cr?: ContextRecorder): Nullable<CCStmt> {
        return this.runner<CCStmt>($$dpth,
            (log) => {
                if (log) {
                    log("CCStmt");
                }
                let res: Nullable<CCStmt> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`chun\s+cinn`, $$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.CCStmt, };
                }
                return res;
            }, cr)();
    }
    public matchToradhStmt($$dpth: number, cr?: ContextRecorder): Nullable<ToradhStmt> {
        return this.runner<ToradhStmt>($$dpth,
            (log) => {
                if (log) {
                    log("ToradhStmt");
                }
                let exp: Nullable<Nullable<Expr>>;
                let res: Nullable<ToradhStmt> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`toradh`, $$dpth + 1, cr) !== null
                    && this.noConsume<gap>(() => this.matchgap($$dpth + 1, cr)) !== null
                    && ((exp = this.matchExpr($$dpth + 1, cr)) || true)
                ) {
                    res = {kind: ASTKinds.ToradhStmt, exp};
                }
                return res;
            }, cr)();
    }
    public matchExpr($$dpth: number, cr?: ContextRecorder): Nullable<Expr> {
        return this.matchAnd($$dpth + 1, cr);
    }
    public matchAnd($$dpth: number, cr?: ContextRecorder): Nullable<And> {
        return this.runner<And>($$dpth,
            (log) => {
                if (log) {
                    log("And");
                }
                let head: Nullable<Or>;
                let tail: Nullable<And_$0[]>;
                let res: Nullable<And> = null;
                if (true
                    && (head = this.matchOr($$dpth + 1, cr)) !== null
                    && (tail = this.loop<And_$0>(() => this.matchAnd_$0($$dpth + 1, cr), true)) !== null
                ) {
                    res = {kind: ASTKinds.And, head, tail};
                }
                return res;
            }, cr)();
    }
    public matchAnd_$0($$dpth: number, cr?: ContextRecorder): Nullable<And_$0> {
        return this.runner<And_$0>($$dpth,
            (log) => {
                if (log) {
                    log("And_$0");
                }
                let trm: Nullable<Or>;
                let res: Nullable<And_$0> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`\&`, $$dpth + 1, cr) !== null
                    && (trm = this.matchOr($$dpth + 1, cr)) !== null
                ) {
                    res = {kind: ASTKinds.And_$0, trm};
                }
                return res;
            }, cr)();
    }
    public matchOr($$dpth: number, cr?: ContextRecorder): Nullable<Or> {
        return this.runner<Or>($$dpth,
            (log) => {
                if (log) {
                    log("Or");
                }
                let head: Nullable<Eq>;
                let tail: Nullable<Or_$0[]>;
                let res: Nullable<Or> = null;
                if (true
                    && (head = this.matchEq($$dpth + 1, cr)) !== null
                    && (tail = this.loop<Or_$0>(() => this.matchOr_$0($$dpth + 1, cr), true)) !== null
                ) {
                    res = {kind: ASTKinds.Or, head, tail};
                }
                return res;
            }, cr)();
    }
    public matchOr_$0($$dpth: number, cr?: ContextRecorder): Nullable<Or_$0> {
        return this.runner<Or_$0>($$dpth,
            (log) => {
                if (log) {
                    log("Or_$0");
                }
                let trm: Nullable<Eq>;
                let res: Nullable<Or_$0> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`\|`, $$dpth + 1, cr) !== null
                    && (trm = this.matchEq($$dpth + 1, cr)) !== null
                ) {
                    res = {kind: ASTKinds.Or_$0, trm};
                }
                return res;
            }, cr)();
    }
    public matchEq($$dpth: number, cr?: ContextRecorder): Nullable<Eq> {
        return this.runner<Eq>($$dpth,
            (log) => {
                if (log) {
                    log("Eq");
                }
                let head: Nullable<Comp>;
                let tail: Nullable<Eq_$0[]>;
                let res: Nullable<Eq> = null;
                if (true
                    && (head = this.matchComp($$dpth + 1, cr)) !== null
                    && (tail = this.loop<Eq_$0>(() => this.matchEq_$0($$dpth + 1, cr), true)) !== null
                ) {
                    res = {kind: ASTKinds.Eq, head, tail};
                }
                return res;
            }, cr)();
    }
    public matchEq_$0($$dpth: number, cr?: ContextRecorder): Nullable<Eq_$0> {
        return this.runner<Eq_$0>($$dpth,
            (log) => {
                if (log) {
                    log("Eq_$0");
                }
                let op: Nullable<string>;
                let trm: Nullable<Comp>;
                let res: Nullable<Eq_$0> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && (op = this.regexAccept(String.raw`[!=]=`, $$dpth + 1, cr)) !== null
                    && (trm = this.matchComp($$dpth + 1, cr)) !== null
                ) {
                    res = {kind: ASTKinds.Eq_$0, op, trm};
                }
                return res;
            }, cr)();
    }
    public matchComp($$dpth: number, cr?: ContextRecorder): Nullable<Comp> {
        return this.runner<Comp>($$dpth,
            (log) => {
                if (log) {
                    log("Comp");
                }
                let head: Nullable<Sum>;
                let tail: Nullable<Comp_$0[]>;
                let res: Nullable<Comp> = null;
                if (true
                    && (head = this.matchSum($$dpth + 1, cr)) !== null
                    && (tail = this.loop<Comp_$0>(() => this.matchComp_$0($$dpth + 1, cr), true)) !== null
                ) {
                    res = {kind: ASTKinds.Comp, head, tail};
                }
                return res;
            }, cr)();
    }
    public matchComp_$0($$dpth: number, cr?: ContextRecorder): Nullable<Comp_$0> {
        return this.runner<Comp_$0>($$dpth,
            (log) => {
                if (log) {
                    log("Comp_$0");
                }
                let op: Nullable<Compare>;
                let trm: Nullable<Sum>;
                let res: Nullable<Comp_$0> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && (op = this.matchCompare($$dpth + 1, cr)) !== null
                    && (trm = this.matchSum($$dpth + 1, cr)) !== null
                ) {
                    res = {kind: ASTKinds.Comp_$0, op, trm};
                }
                return res;
            }, cr)();
    }
    public matchSum($$dpth: number, cr?: ContextRecorder): Nullable<Sum> {
        return this.runner<Sum>($$dpth,
            (log) => {
                if (log) {
                    log("Sum");
                }
                let head: Nullable<Product>;
                let tail: Nullable<Sum_$0[]>;
                let res: Nullable<Sum> = null;
                if (true
                    && (head = this.matchProduct($$dpth + 1, cr)) !== null
                    && (tail = this.loop<Sum_$0>(() => this.matchSum_$0($$dpth + 1, cr), true)) !== null
                ) {
                    res = {kind: ASTKinds.Sum, head, tail};
                }
                return res;
            }, cr)();
    }
    public matchSum_$0($$dpth: number, cr?: ContextRecorder): Nullable<Sum_$0> {
        return this.runner<Sum_$0>($$dpth,
            (log) => {
                if (log) {
                    log("Sum_$0");
                }
                let op: Nullable<PlusMinus>;
                let trm: Nullable<Product>;
                let res: Nullable<Sum_$0> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && (op = this.matchPlusMinus($$dpth + 1, cr)) !== null
                    && (trm = this.matchProduct($$dpth + 1, cr)) !== null
                ) {
                    res = {kind: ASTKinds.Sum_$0, op, trm};
                }
                return res;
            }, cr)();
    }
    public matchProduct($$dpth: number, cr?: ContextRecorder): Nullable<Product> {
        return this.runner<Product>($$dpth,
            (log) => {
                if (log) {
                    log("Product");
                }
                let head: Nullable<Prefix>;
                let tail: Nullable<Product_$0[]>;
                let res: Nullable<Product> = null;
                if (true
                    && (head = this.matchPrefix($$dpth + 1, cr)) !== null
                    && (tail = this.loop<Product_$0>(() => this.matchProduct_$0($$dpth + 1, cr), true)) !== null
                ) {
                    res = {kind: ASTKinds.Product, head, tail};
                }
                return res;
            }, cr)();
    }
    public matchProduct_$0($$dpth: number, cr?: ContextRecorder): Nullable<Product_$0> {
        return this.runner<Product_$0>($$dpth,
            (log) => {
                if (log) {
                    log("Product_$0");
                }
                let op: Nullable<MulDiv>;
                let trm: Nullable<Prefix>;
                let res: Nullable<Product_$0> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && (op = this.matchMulDiv($$dpth + 1, cr)) !== null
                    && (trm = this.matchPrefix($$dpth + 1, cr)) !== null
                ) {
                    res = {kind: ASTKinds.Product_$0, op, trm};
                }
                return res;
            }, cr)();
    }
    public matchPrefix($$dpth: number, cr?: ContextRecorder): Nullable<Prefix> {
        return this.runner<Prefix>($$dpth,
            (log) => {
                if (log) {
                    log("Prefix");
                }
                let op: Nullable<Nullable<string>>;
                let pf: Nullable<Postfix>;
                let res: Nullable<Prefix> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && ((op = this.regexAccept(String.raw`-|!`, $$dpth + 1, cr)) || true)
                    && (pf = this.matchPostfix($$dpth + 1, cr)) !== null
                ) {
                    res = {kind: ASTKinds.Prefix, op, pf};
                }
                return res;
            }, cr)();
    }
    public matchPostfix($$dpth: number, cr?: ContextRecorder): Nullable<Postfix> {
        return this.runner<Postfix>($$dpth,
            (log) => {
                if (log) {
                    log("Postfix");
                }
                let at: Nullable<ObjLookups>;
                let ops: Nullable<PostOp[]>;
                let res: Nullable<Postfix> = null;
                if (true
                    && (at = this.matchObjLookups($$dpth + 1, cr)) !== null
                    && (ops = this.loop<PostOp>(() => this.matchPostOp($$dpth + 1, cr), true)) !== null
                ) {
                    res = {kind: ASTKinds.Postfix, at, ops};
                }
                return res;
            }, cr)();
    }
    public matchPostOp($$dpth: number, cr?: ContextRecorder): Nullable<PostOp> {
        return this.choice<PostOp>([
            () => this.matchPostOp_1($$dpth + 1, cr),
            () => this.matchPostOp_2($$dpth + 1, cr),
        ]);
    }
    public matchPostOp_1($$dpth: number, cr?: ContextRecorder): Nullable<PostOp_1> {
        return this.runner<PostOp_1>($$dpth,
            (log) => {
                if (log) {
                    log("PostOp_1");
                }
                let args: Nullable<Nullable<CSArgs>>;
                let res: Nullable<PostOp_1> = null;
                if (true
                    && this.regexAccept(String.raw`\(`, $$dpth + 1, cr) !== null
                    && ((args = this.matchCSArgs($$dpth + 1, cr)) || true)
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`\)`, $$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.PostOp_1, args};
                }
                return res;
            }, cr)();
    }
    public matchPostOp_2($$dpth: number, cr?: ContextRecorder): Nullable<PostOp_2> {
        return this.runner<PostOp_2>($$dpth,
            (log) => {
                if (log) {
                    log("PostOp_2");
                }
                let expr: Nullable<Expr>;
                let res: Nullable<PostOp_2> = null;
                if (true
                    && this.regexAccept(String.raw`\[`, $$dpth + 1, cr) !== null
                    && (expr = this.matchExpr($$dpth + 1, cr)) !== null
                    && this.regexAccept(String.raw`\]`, $$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.PostOp_2, expr};
                }
                return res;
            }, cr)();
    }
    public matchAtom($$dpth: number, cr?: ContextRecorder): Nullable<Atom> {
        return this.choice<Atom>([
            () => this.matchAtom_1($$dpth + 1, cr),
            () => this.matchAtom_2($$dpth + 1, cr),
            () => this.matchAtom_3($$dpth + 1, cr),
            () => this.matchAtom_4($$dpth + 1, cr),
            () => this.matchAtom_5($$dpth + 1, cr),
            () => this.matchAtom_6($$dpth + 1, cr),
            () => this.matchAtom_7($$dpth + 1, cr),
        ]);
    }
    public matchAtom_1($$dpth: number, cr?: ContextRecorder): Nullable<Atom_1> {
        return this.runner<Atom_1>($$dpth,
            (log) => {
                if (log) {
                    log("Atom_1");
                }
                let trm: Nullable<Expr>;
                let res: Nullable<Atom_1> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`\(`, $$dpth + 1, cr) !== null
                    && (trm = this.matchExpr($$dpth + 1, cr)) !== null
                    && this.regexAccept(String.raw`\)`, $$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.Atom_1, trm};
                }
                return res;
            }, cr)();
    }
    public matchAtom_2($$dpth: number, cr?: ContextRecorder): Nullable<Atom_2> {
        return this.matchID($$dpth + 1, cr);
    }
    public matchAtom_3($$dpth: number, cr?: ContextRecorder): Nullable<Atom_3> {
        return this.matchLitreacha($$dpth + 1, cr);
    }
    public matchAtom_4($$dpth: number, cr?: ContextRecorder): Nullable<Atom_4> {
        return this.matchInt($$dpth + 1, cr);
    }
    public matchAtom_5($$dpth: number, cr?: ContextRecorder): Nullable<Atom_5> {
        return this.matchBool($$dpth + 1, cr);
    }
    public matchAtom_6($$dpth: number, cr?: ContextRecorder): Nullable<Atom_6> {
        return this.matchNeamhni($$dpth + 1, cr);
    }
    public matchAtom_7($$dpth: number, cr?: ContextRecorder): Nullable<Atom_7> {
        return this.matchListLit($$dpth + 1, cr);
    }
    public matchLSpec($$dpth: number, cr?: ContextRecorder): Nullable<LSpec> {
        return this.runner<LSpec>($$dpth,
            (log) => {
                if (log) {
                    log("LSpec");
                }
                let id: Nullable<ID>;
                let ops: Nullable<PostOp[]>;
                let res: Nullable<LSpec> = null;
                if (true
                    && (id = this.matchID($$dpth + 1, cr)) !== null
                    && (ops = this.loop<PostOp>(() => this.matchPostOp($$dpth + 1, cr), true)) !== null
                ) {
                    res = {kind: ASTKinds.LSpec, id, ops};
                }
                return res;
            }, cr)();
    }
    public matchCSArgs($$dpth: number, cr?: ContextRecorder): Nullable<CSArgs> {
        return this.runner<CSArgs>($$dpth,
            (log) => {
                if (log) {
                    log("CSArgs");
                }
                let head: Nullable<Expr>;
                let tail: Nullable<CSArgs_$0[]>;
                let res: Nullable<CSArgs> = null;
                if (true
                    && (head = this.matchExpr($$dpth + 1, cr)) !== null
                    && (tail = this.loop<CSArgs_$0>(() => this.matchCSArgs_$0($$dpth + 1, cr), true)) !== null
                ) {
                    res = {kind: ASTKinds.CSArgs, head, tail};
                }
                return res;
            }, cr)();
    }
    public matchCSArgs_$0($$dpth: number, cr?: ContextRecorder): Nullable<CSArgs_$0> {
        return this.runner<CSArgs_$0>($$dpth,
            (log) => {
                if (log) {
                    log("CSArgs_$0");
                }
                let exp: Nullable<Expr>;
                let res: Nullable<CSArgs_$0> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`,`, $$dpth + 1, cr) !== null
                    && (exp = this.matchExpr($$dpth + 1, cr)) !== null
                ) {
                    res = {kind: ASTKinds.CSArgs_$0, exp};
                }
                return res;
            }, cr)();
    }
    public matchCSIDs($$dpth: number, cr?: ContextRecorder): Nullable<CSIDs> {
        return this.runner<CSIDs>($$dpth,
            (log) => {
                if (log) {
                    log("CSIDs");
                }
                let head: Nullable<ID>;
                let tail: Nullable<CSIDs_$0[]>;
                let res: Nullable<CSIDs> = null;
                if (true
                    && (head = this.matchID($$dpth + 1, cr)) !== null
                    && (tail = this.loop<CSIDs_$0>(() => this.matchCSIDs_$0($$dpth + 1, cr), true)) !== null
                ) {
                    res = {kind: ASTKinds.CSIDs, head, tail};
                }
                return res;
            }, cr)();
    }
    public matchCSIDs_$0($$dpth: number, cr?: ContextRecorder): Nullable<CSIDs_$0> {
        return this.runner<CSIDs_$0>($$dpth,
            (log) => {
                if (log) {
                    log("CSIDs_$0");
                }
                let id: Nullable<ID>;
                let res: Nullable<CSIDs_$0> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`,`, $$dpth + 1, cr) !== null
                    && (id = this.matchID($$dpth + 1, cr)) !== null
                ) {
                    res = {kind: ASTKinds.CSIDs_$0, id};
                }
                return res;
            }, cr)();
    }
    public matchListLit($$dpth: number, cr?: ContextRecorder): Nullable<ListLit> {
        return this.runner<ListLit>($$dpth,
            (log) => {
                if (log) {
                    log("ListLit");
                }
                let els: Nullable<Nullable<CSArgs>>;
                let res: Nullable<ListLit> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`\[`, $$dpth + 1, cr) !== null
                    && ((els = this.matchCSArgs($$dpth + 1, cr)) || true)
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`\]`, $$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.ListLit, els};
                }
                return res;
            }, cr)();
    }
    public matchPlusMinus($$dpth: number, cr?: ContextRecorder): Nullable<PlusMinus> {
        return this.regexAccept(String.raw`\+|-`, $$dpth + 1, cr);
    }
    public matchMulDiv($$dpth: number, cr?: ContextRecorder): Nullable<MulDiv> {
        return this.regexAccept(String.raw`\*|\/|%`, $$dpth + 1, cr);
    }
    public matchCompare($$dpth: number, cr?: ContextRecorder): Nullable<Compare> {
        return this.regexAccept(String.raw`(<=)|(>=)|<|>`, $$dpth + 1, cr);
    }
    public matchKeyword($$dpth: number, cr?: ContextRecorder): Nullable<Keyword> {
        return this.choice<Keyword>([
            () => this.matchKeyword_1($$dpth + 1, cr),
            () => this.matchKeyword_2($$dpth + 1, cr),
            () => this.matchKeyword_3($$dpth + 1, cr),
            () => this.matchKeyword_4($$dpth + 1, cr),
            () => this.matchKeyword_5($$dpth + 1, cr),
            () => this.matchKeyword_6($$dpth + 1, cr),
            () => this.matchKeyword_7($$dpth + 1, cr),
            () => this.matchKeyword_8($$dpth + 1, cr),
            () => this.matchKeyword_9($$dpth + 1, cr),
        ]);
    }
    public matchKeyword_1($$dpth: number, cr?: ContextRecorder): Nullable<Keyword_1> {
        return this.regexAccept(String.raw`m[áa]`, $$dpth + 1, cr);
    }
    public matchKeyword_2($$dpth: number, cr?: ContextRecorder): Nullable<Keyword_2> {
        return this.regexAccept(String.raw`n[oó]`, $$dpth + 1, cr);
    }
    public matchKeyword_3($$dpth: number, cr?: ContextRecorder): Nullable<Keyword_3> {
        return this.regexAccept(String.raw`nuair\s+a`, $$dpth + 1, cr);
    }
    public matchKeyword_4($$dpth: number, cr?: ContextRecorder): Nullable<Keyword_4> {
        return this.regexAccept(String.raw`f[ií]or|breag`, $$dpth + 1, cr);
    }
    public matchKeyword_5($$dpth: number, cr?: ContextRecorder): Nullable<Keyword_5> {
        return this.regexAccept(String.raw`gn[ií]omh`, $$dpth + 1, cr);
    }
    public matchKeyword_6($$dpth: number, cr?: ContextRecorder): Nullable<Keyword_6> {
        return this.regexAccept(String.raw`chun\s+cinn`, $$dpth + 1, cr);
    }
    public matchKeyword_7($$dpth: number, cr?: ContextRecorder): Nullable<Keyword_7> {
        return this.regexAccept(String.raw`neamhn[ií]`, $$dpth + 1, cr);
    }
    public matchKeyword_8($$dpth: number, cr?: ContextRecorder): Nullable<Keyword_8> {
        return this.regexAccept(String.raw`toradh`, $$dpth + 1, cr);
    }
    public matchKeyword_9($$dpth: number, cr?: ContextRecorder): Nullable<Keyword_9> {
        return this.regexAccept(String.raw`creatlach`, $$dpth + 1, cr);
    }
    public matchID($$dpth: number, cr?: ContextRecorder): Nullable<ID> {
        return this.runner<ID>($$dpth,
            (log) => {
                if (log) {
                    log("ID");
                }
                let id: Nullable<string>;
                let res: Nullable<ID> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.negate(() => this.matchID_$0($$dpth + 1, cr)) !== null
                    && (id = this.regexAccept(String.raw`[a-zA-Z_áéíóúÁÉÍÓÚ]+`, $$dpth + 1, cr)) !== null
                ) {
                    res = {kind: ASTKinds.ID, id};
                }
                return res;
            }, cr)();
    }
    public matchID_$0($$dpth: number, cr?: ContextRecorder): Nullable<ID_$0> {
        return this.runner<ID_$0>($$dpth,
            (log) => {
                if (log) {
                    log("ID_$0");
                }
                let res: Nullable<ID_$0> = null;
                if (true
                    && this.matchKeyword($$dpth + 1, cr) !== null
                    && this.matchgap($$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.ID_$0, };
                }
                return res;
            }, cr)();
    }
    public matchBool($$dpth: number, cr?: ContextRecorder): Nullable<Bool> {
        return this.runner<Bool>($$dpth,
            (log) => {
                if (log) {
                    log("Bool");
                }
                let bool: Nullable<string>;
                let res: Nullable<Bool> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && (bool = this.regexAccept(String.raw`f[ií]or|breag`, $$dpth + 1, cr)) !== null
                ) {
                    res = {kind: ASTKinds.Bool, bool};
                }
                return res;
            }, cr)();
    }
    public matchNeamhni($$dpth: number, cr?: ContextRecorder): Nullable<Neamhni> {
        return this.runner<Neamhni>($$dpth,
            (log) => {
                if (log) {
                    log("Neamhni");
                }
                let res: Nullable<Neamhni> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`neamhn[ií]`, $$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.Neamhni, };
                }
                return res;
            }, cr)();
    }
    public matchInt($$dpth: number, cr?: ContextRecorder): Nullable<Int> {
        return this.runner<Int>($$dpth,
            (log) => {
                if (log) {
                    log("Int");
                }
                let int: Nullable<string>;
                let res: Nullable<Int> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && (int = this.regexAccept(String.raw`-?[0-9]+`, $$dpth + 1, cr)) !== null
                ) {
                    res = {kind: ASTKinds.Int, int};
                }
                return res;
            }, cr)();
    }
    public matchLitreacha($$dpth: number, cr?: ContextRecorder): Nullable<Litreacha> {
        return this.runner<Litreacha>($$dpth,
            (log) => {
                if (log) {
                    log("Litreacha");
                }
                let val: Nullable<string>;
                let res: Nullable<Litreacha> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`\'`, $$dpth + 1, cr) !== null
                    && (val = this.regexAccept(String.raw`([^\'\\]|(\\.))*`, $$dpth + 1, cr)) !== null
                    && this.regexAccept(String.raw`\'`, $$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.Litreacha, val};
                }
                return res;
            }, cr)();
    }
    public matchObjLookups($$dpth: number, cr?: ContextRecorder): Nullable<ObjLookups> {
        return this.runner<ObjLookups>($$dpth,
            (log) => {
                if (log) {
                    log("ObjLookups");
                }
                let attrs: Nullable<ObjLookups_$0[]>;
                let root: Nullable<Atom>;
                let res: Nullable<ObjLookups> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && (attrs = this.loop<ObjLookups_$0>(() => this.matchObjLookups_$0($$dpth + 1, cr), true)) !== null
                    && (root = this.matchAtom($$dpth + 1, cr)) !== null
                ) {
                    res = {kind: ASTKinds.ObjLookups, attrs, root};
                }
                return res;
            }, cr)();
    }
    public matchObjLookups_$0($$dpth: number, cr?: ContextRecorder): Nullable<ObjLookups_$0> {
        return this.runner<ObjLookups_$0>($$dpth,
            (log) => {
                if (log) {
                    log("ObjLookups_$0");
                }
                let id: Nullable<ID>;
                let res: Nullable<ObjLookups_$0> = null;
                if (true
                    && (id = this.matchID($$dpth + 1, cr)) !== null
                    && this.regexAccept(String.raw`@`, $$dpth + 1, cr) !== null
                    && this.negate(() => this.matchwspace($$dpth + 1, cr)) !== null
                ) {
                    res = {kind: ASTKinds.ObjLookups_$0, id};
                }
                return res;
            }, cr)();
    }
    public match_($$dpth: number, cr?: ContextRecorder): Nullable<_> {
        return this.loop<wspace>(() => this.matchwspace($$dpth + 1, cr), true);
    }
    public matchwspace($$dpth: number, cr?: ContextRecorder): Nullable<wspace> {
        return this.regexAccept(String.raw`(?:\s|>--(?:(?!--<).)*(--<|\n))`, $$dpth + 1, cr);
    }
    public matchgap($$dpth: number, cr?: ContextRecorder): Nullable<gap> {
        return this.choice<gap>([
            () => this.matchgap_1($$dpth + 1, cr),
            () => this.matchgap_2($$dpth + 1, cr),
        ]);
    }
    public matchgap_1($$dpth: number, cr?: ContextRecorder): Nullable<gap_1> {
        return this.loop<gap_$0>(() => this.matchgap_$0($$dpth + 1, cr), false);
    }
    public matchgap_2($$dpth: number, cr?: ContextRecorder): Nullable<gap_2> {
        return this.regexAccept(String.raw`$`, $$dpth + 1, cr);
    }
    public matchgap_$0($$dpth: number, cr?: ContextRecorder): Nullable<gap_$0> {
        return this.choice<gap_$0>([
            () => this.matchgap_$0_1($$dpth + 1, cr),
            () => this.matchgap_$0_2($$dpth + 1, cr),
        ]);
    }
    public matchgap_$0_1($$dpth: number, cr?: ContextRecorder): Nullable<gap_$0_1> {
        return this.matchwspace($$dpth + 1, cr);
    }
    public matchgap_$0_2($$dpth: number, cr?: ContextRecorder): Nullable<gap_$0_2> {
        return this.regexAccept(String.raw`[^a-zA-Z0-9áéíóúÁÉÍÓÚ]`, $$dpth + 1, cr);
    }
    public parse(): ParseResult {
        const mrk = this.mark();
        const res = this.matchProgram(0);
        if (res && this.finished()) {
            return new ParseResult(res, null);
        }
        this.reset(mrk);
        const rec = new ErrorTracker();
        this.matchProgram(0, rec);
        return new ParseResult(res, rec.getErr());
    }
    private mark(): PosInfo {
        return this.pos;
    }
    private loop<T>(func: $$RuleType<T>, star: boolean = false): Nullable<T[]> {
        const mrk = this.mark();
        const res: T[] = [];
        for (;;) {
            const t = func();
            if (!t) {
                break;
            }
            res.push(t);
        }
        if (star || res.length > 0) {
            return res;
        }
        this.reset(mrk);
        return null;
    }
    private runner<T>($$dpth: number, fn: $$RuleType<T>, cr?: ContextRecorder): $$RuleType<T> {
        return () => {
            const mrk = this.mark();
            const res = cr ? (() => {
                const extraInfo: string[] = [];
                const result = fn((msg: string) => extraInfo.push(msg));
                cr.record(mrk, $$dpth, result, this.negating, extraInfo);
                return result;
            })() : fn();
            if (res !== null) {
                return res;
            }
            this.reset(mrk);
            return null;
        };
    }
    private choice<T>(fns: Array<$$RuleType<T>>): Nullable<T> {
        for (const f of fns) {
            const res = f();
            if (res !== null) {
                return res;
            }
        }
        return null;
    }
    private regexAccept(match: string, dpth: number, cr?: ContextRecorder): Nullable<string> {
        return this.runner<string>(dpth,
            (log) => {
                if (log) {
                    if (this.negating) {
                        log("$$!StrMatch");
                    } else {
                        log("$$StrMatch");
                    }
                    log(match);
                }
                const reg = new RegExp(match, "y");
                reg.lastIndex = this.mark().overallPos;
                const res = reg.exec(this.input);
                if (res) {
                    let lineJmp = 0;
                    let lind = -1;
                    for (let i = 0; i < res[0].length; ++i) {
                        if (res[0][i] === "\n") {
                            ++lineJmp;
                            lind = i;
                        }
                    }
                    this.pos = new PosInfo(reg.lastIndex, this.pos.line + lineJmp,
                       lind === -1 ? this.pos.offset + res[0].length : (res[0].length - lind));
                    return res[0];
                }
                return null;
            }, cr)();
    }
    private noConsume<T>(fn: $$RuleType<T>): Nullable<T> {
        const mrk = this.mark();
        const res = fn();
        this.reset(mrk);
        return res;
    }
    private negate<T>(fn: $$RuleType<T>): Nullable<boolean> {
        const mrk = this.mark();
        const oneg = this.negating;
        this.negating = !oneg;
        const res = fn();
        this.negating = oneg;
        this.reset(mrk);
        return res === null ? true : null;
    }
}
export class ParseResult {
    public ast: Nullable<Program>;
    public err: Nullable<SyntaxErr>;
    constructor(ast: Nullable<Program>, err: Nullable<SyntaxErr>) {
        this.ast = ast;
        this.err = err;
    }
}
export class PosInfo {
    public overallPos: number;
    public line: number;
    public offset: number;
    constructor(overallPos: number, line: number, offset: number) {
        this.overallPos = overallPos;
        this.line = line;
        this.offset = offset;
    }
}
export class SyntaxErr {
    public pos: PosInfo;
    public exprules: string[];
    public expmatches: string[];
    constructor(pos: PosInfo, exprules: Set<string>, expmatches: Set<string>) {
        this.pos = pos;
        this.exprules = [...exprules];
        this.expmatches = [...expmatches];
    }
    public toString(): string {
        return `Syntax Error at line ${this.pos.line}:${this.pos.offset}. Tried to match rules ${this.exprules.join(", ")}. Expected one of ${this.expmatches.map((x) => ` '${x}'`)}`;
    }
}
class ErrorTracker implements ContextRecorder {
    private mxpos: PosInfo = new PosInfo(-1, -1, -1);
    private mnd: number = -1;
    private prules: Set<string> = new Set();
    private pmatches: Set<string> = new Set();
    public record(pos: PosInfo, depth: number, result: any, negating: boolean, extraInfo: string[]) {
        if ((result === null) === negating) {
            return;
        }
        if (pos.overallPos > this.mxpos.overallPos) {
            this.mxpos = pos;
            this.mnd = depth;
            this.pmatches.clear();
            this.prules.clear();
        } else if (pos.overallPos === this.mxpos.overallPos && depth < this.mnd) {
            this.mnd = depth;
            this.prules.clear();
        }
        if (this.mxpos.overallPos === pos.overallPos && extraInfo.length >= 2) {
            if (extraInfo[0] === "$$StrMatch") {
                this.pmatches.add(extraInfo[1]);
            }
            if (extraInfo[0] === "$$!StrMatch") {
                this.pmatches.add(`not ${extraInfo[1]}`);
            }
        }
        if (this.mxpos.overallPos === pos.overallPos && this.mnd === depth) {
            extraInfo.forEach((x) => { if (x !== "$$StrMatch" && x !== "$$!StrMatch") { this.prules.add(x); } });
        }
    }
    public getErr(): SyntaxErr | null {
        if (this.mxpos.overallPos !== -1) {
            return new SyntaxErr(this.mxpos, this.prules, this.pmatches);
        }
        return null;
    }
}
/* AutoGenerated Code, changes may be overwritten
* INPUT GRAMMAR:
* ---
* import { Environment } from "./env";
* import { callFunc, idxList, Value } from "./values";
* import { unescapeChars } from "./litreacha";
* import * as Asserts from "./asserts";
* import * as Checks from "./checks";
* import { orBinOp, orQuickBinOp, andBinOp, andQuickBinOp,
*     binOpEvalFn, binOpQuickEvalFn } from "./binops";
* import { objLookupsEval, postfixArgsEval, csArgsEval, prefEval, EvalFn } from "./evals";
* import { qEvalToEval } from "./evals";
* import * as Quick from "./quickevals";
* ---
* Program     := stmts=AsgnStmt* _
* AsgnStmt    := IfStmt
*              | BlockStmt
*              | NuairStmt
*              | LeStmt
*              | CCStmt
*              | BrisStmt
*              | CtlchStmt
*              | GniomhStmt
*              | ToradhStmt
*              | AssgnStmt
*              | DefnStmt
*              | Expr
* NonAsgnStmt := IfStmt
*              | NuairStmt
*              | LeStmt
*              | CCStmt
*              | BrisStmt
*              | ToradhStmt
*              | BlockStmt
*              | AssgnStmt
*              | Expr
* IfStmt      := _ 'm[áa]' &gap expr=Expr &gap stmt=NonAsgnStmt elsebranch={_ 'n[oó]' &gap stmt=NonAsgnStmt}?
* BlockStmt   := _ '{' blk=AsgnStmt* _ '}'
* NuairStmt   := _ 'nuair-a' expr=Expr &gap stmt=NonAsgnStmt
* LeStmt      := _ 'le' &gap id=ID _ 'idir' _ '\('strt=Expr _ ',' end=Expr step={_ ',' step=Expr}? _ '\)' stmt=NonAsgnStmt
* DefnStmt    := _ idstart=@ id=ID idend=@ _ ':=' _ expr=Expr
* AssgnStmt   := _ lhs=Postfix _ op=AsgnOp _ expr=Expr
* GniomhStmt  := _ 'gn[íi]omh' &gap id=ID _ '\(' args=CSIDs? _ '\)' _ '{'
*     stmts=AsgnStmt*
* _ '}'
* CtlchStmt   := _ 'creatlach' &gap id=ID tuis={_ 'ó' &gap parentstart=@ id=ID parentend=@}? _ '{'
*     gniomhs=GniomhStmt*
* _ '}'
* BrisStmt    := _ 'bris'
* CCStmt      := _ 'chun-cinn'
* ToradhStmt  := _ 'toradh' &gap exp=Expr?
* Expr        := And
* And         := head=Or tail={_ '\&' trm=Or}*
*                .evalfn = EvalFn { return andBinOp(this); }
*                .qeval = Quick.MaybeEv { return andQuickBinOp(this); }
* Or          := head=Eq tail={_ '\|' trm=Eq}*
*                .evalfn = EvalFn { return orBinOp(this) }
*                .qeval = Quick.MaybeEv { return orQuickBinOp(this); }
* Eq          := head=Comp tail={_ op='[!=]=' trm=Comp}*
*                .evalfn = EvalFn { return binOpEvalFn(this) }
*                .qeval = Quick.MaybeEv { return binOpQuickEvalFn(this); }
* Comp        := head=Sum tail={_ op=Compare trm=Sum}*
*                .evalfn = EvalFn { return binOpEvalFn(this) }
*                .qeval = Quick.MaybeEv { return binOpQuickEvalFn(this); }
* Sum         := head=Product tail={_ op=PlusMinus trm=Product}*
*                .evalfn = EvalFn { return binOpEvalFn(this) }
*                .qeval = Quick.MaybeEv { return binOpQuickEvalFn(this); }
* Product     := head=Prefix tail={_ op=MulDiv trm=Prefix}*
*                .evalfn = EvalFn { return binOpEvalFn(this); }
*                .qeval = Quick.MaybeEv { return binOpQuickEvalFn(this); }
* Prefix      := _ op='-|!'? pf=Postfix
*                .evalfn = EvalFn { return prefEval(this); }
*                .qeval = Quick.MaybeEv { return Quick.qPrefEval(this); }
* Postfix     := start=@ at=ObjLookups ops=PostOp* end=@
*                .evalfn = EvalFn { return postfixArgsEval(this); }
*                .qeval = Quick.MaybeEv { return Quick.qPostfixArgsEval(this); }
* ObjLookups  := attrs={id=ID '@' !wspace}* root=Atom
*                .evalfn = EvalFn { return objLookupsEval(this); }
*                .qeval = Quick.MaybeEv { return Quick.qObjLookupsEval(this); }
* PostOp      := '\(' args=CSArgs? _ '\)' | '\[' expr=Expr _ '\]'
* Atom        :=  _ '\(' trm=Expr '\)'
*                .evalfn = EvalFn { return (env: Environment) => this.trm.evalfn(env); }
*                .qeval = Quick.MaybeEv {
*                     const childF = this.trm.qeval;
*                     return childF === null ? null : childF.bind(this.trm);
*                }
*              | ID
*              | Litreacha
*              | Int
*              | Bool
*              | Neamhni
*              | ListLit
* ListLit     := _ '\[' els=CSArgs? _ '\]'
*                .evalfn = EvalFn {
*                    return (env: Environment) => this.els ? this.els.evalfn(env) : Promise.resolve([]);
*                }
*                .qeval = Quick.MaybeEv { return Quick.qListLitEval(this); }
* CSArgs      := head=Expr tail={_ ',' exp=Expr}*
*                .evalfn = (env:Environment)=>Promise<Value[]> { return csArgsEval(this); }
*                .qeval = ((env:Environment)=>Value[])|null { return Quick.qCSArgsEval(this); }
* CSIDs       := head=ID tail={_ ',' id=ID}*
* ID          := _ !{Keyword gap} id='[a-zA-Z_áéíóúÁÉÍÓÚ]+'
*                .evalfn = EvalFn { return qEvalToEval(Quick.qIdEval(this.id)); }
*                .qeval = Quick.EvalFn { return Quick.qIdEval(this.id); }
* Bool        := _ bool='f[ií]or|br[eé]ag'
*                .evalfn = EvalFn { return qEvalToEval(Quick.qBoolEval(this.bool)); }
*                .qeval = Quick.EvalFn { return Quick.qBoolEval(this.bool); }
* Neamhni     := _ 'neamhn[ií]'
*                .evalfn = EvalFn { return () => Promise.resolve(null); }
*                .qeval = Quick.EvalFn { return () => null; }
* Int         := _ int='-?[0-9]+(?:\.[0-9]+)?'
*                .evalfn = EvalFn { return qEvalToEval(Quick.qIntEval(this.int)); }
*                .qeval = Quick.EvalFn { return Quick.qIntEval(this.int); }
* Litreacha   := _ '\'' val='([^\'\\]|\\.)*' '\''
*                .evalfn = EvalFn { return qEvalToEval(Quick.qLitreachaEval(this.val)); }
*                .qeval = Quick.EvalFn { return Quick.qLitreachaEval(this.val); }
* _           := wspace*
* wspace      := '(?:\s|>--(?:(?!--<).)*(--<|\n|$))'
* gap         := { wspace | '[^a-zA-Z0-9áéíóúÁÉÍÓÚ]' }+ | '$'
* PlusMinus   := '\+|-'
* AsgnOp      := '=|\+=|\*=|-=|%=|\/='
* MulDiv      := '\*|\/\/|%|\/'
* Compare     := '<=|>=|<|>'
* Keyword     := 'm[áa]' | 'n[oó]' | 'nuair-a' | 'f[ií]or|br[eé]ag'
*     | 'gn[ií]omh' | 'chun-cinn' | 'neamhn[ií]' | 'toradh' | 'creatlach'
*/

import { Environment } from "./env";
import { callFunc, idxList, Value } from "./values";
import { unescapeChars } from "./litreacha";
import * as Asserts from "./asserts";
import * as Checks from "./checks";
import { orBinOp, orQuickBinOp, andBinOp, andQuickBinOp,
    binOpEvalFn, binOpQuickEvalFn } from "./binops";
import { objLookupsEval, postfixArgsEval, csArgsEval, prefEval, EvalFn } from "./evals";
import { qEvalToEval } from "./evals";
import * as Quick from "./quickevals";

type Nullable<T> = T | null;
type $$RuleType<T> = (log?: (msg: string) => void) => Nullable<T>;
export interface ContextRecorder {
    record(pos: PosInfo, depth: number, result: any, negating: boolean, extraInfo: string[]): void;
}
interface ASTNodeIntf {
    kind: ASTKinds;
}
export enum ASTKinds {
    Program,
    AsgnStmt_1,
    AsgnStmt_2,
    AsgnStmt_3,
    AsgnStmt_4,
    AsgnStmt_5,
    AsgnStmt_6,
    AsgnStmt_7,
    AsgnStmt_8,
    AsgnStmt_9,
    AsgnStmt_10,
    AsgnStmt_11,
    AsgnStmt_12,
    NonAsgnStmt_1,
    NonAsgnStmt_2,
    NonAsgnStmt_3,
    NonAsgnStmt_4,
    NonAsgnStmt_5,
    NonAsgnStmt_6,
    NonAsgnStmt_7,
    NonAsgnStmt_8,
    NonAsgnStmt_9,
    IfStmt,
    IfStmt_$0,
    BlockStmt,
    NuairStmt,
    LeStmt,
    LeStmt_$0,
    DefnStmt,
    AssgnStmt,
    GniomhStmt,
    CtlchStmt,
    CtlchStmt_$0,
    BrisStmt,
    CCStmt,
    ToradhStmt,
    Expr,
    And,
    And_$0,
    Or,
    Or_$0,
    Eq,
    Eq_$0,
    Comp,
    Comp_$0,
    Sum,
    Sum_$0,
    Product,
    Product_$0,
    Prefix,
    Postfix,
    ObjLookups,
    ObjLookups_$0,
    PostOp_1,
    PostOp_2,
    Atom_1,
    Atom_2,
    Atom_3,
    Atom_4,
    Atom_5,
    Atom_6,
    Atom_7,
    ListLit,
    CSArgs,
    CSArgs_$0,
    CSIDs,
    CSIDs_$0,
    ID,
    ID_$0,
    Bool,
    Neamhni,
    Int,
    Litreacha,
    _,
    wspace,
    gap_1,
    gap_2,
    gap_$0_1,
    gap_$0_2,
    PlusMinus,
    AsgnOp,
    MulDiv,
    Compare,
    Keyword_1,
    Keyword_2,
    Keyword_3,
    Keyword_4,
    Keyword_5,
    Keyword_6,
    Keyword_7,
    Keyword_8,
    Keyword_9,
}
export interface Program {
    kind: ASTKinds.Program;
    stmts: AsgnStmt[];
}
export type AsgnStmt = AsgnStmt_1 | AsgnStmt_2 | AsgnStmt_3 | AsgnStmt_4 | AsgnStmt_5 | AsgnStmt_6 | AsgnStmt_7 | AsgnStmt_8 | AsgnStmt_9 | AsgnStmt_10 | AsgnStmt_11 | AsgnStmt_12;
export type AsgnStmt_1 = IfStmt;
export type AsgnStmt_2 = BlockStmt;
export type AsgnStmt_3 = NuairStmt;
export type AsgnStmt_4 = LeStmt;
export type AsgnStmt_5 = CCStmt;
export type AsgnStmt_6 = BrisStmt;
export type AsgnStmt_7 = CtlchStmt;
export type AsgnStmt_8 = GniomhStmt;
export type AsgnStmt_9 = ToradhStmt;
export type AsgnStmt_10 = AssgnStmt;
export type AsgnStmt_11 = DefnStmt;
export type AsgnStmt_12 = Expr;
export type NonAsgnStmt = NonAsgnStmt_1 | NonAsgnStmt_2 | NonAsgnStmt_3 | NonAsgnStmt_4 | NonAsgnStmt_5 | NonAsgnStmt_6 | NonAsgnStmt_7 | NonAsgnStmt_8 | NonAsgnStmt_9;
export type NonAsgnStmt_1 = IfStmt;
export type NonAsgnStmt_2 = NuairStmt;
export type NonAsgnStmt_3 = LeStmt;
export type NonAsgnStmt_4 = CCStmt;
export type NonAsgnStmt_5 = BrisStmt;
export type NonAsgnStmt_6 = ToradhStmt;
export type NonAsgnStmt_7 = BlockStmt;
export type NonAsgnStmt_8 = AssgnStmt;
export type NonAsgnStmt_9 = Expr;
export interface IfStmt {
    kind: ASTKinds.IfStmt;
    expr: Expr;
    stmt: NonAsgnStmt;
    elsebranch: Nullable<IfStmt_$0>;
}
export interface IfStmt_$0 {
    kind: ASTKinds.IfStmt_$0;
    stmt: NonAsgnStmt;
}
export interface BlockStmt {
    kind: ASTKinds.BlockStmt;
    blk: AsgnStmt[];
}
export interface NuairStmt {
    kind: ASTKinds.NuairStmt;
    expr: Expr;
    stmt: NonAsgnStmt;
}
export interface LeStmt {
    kind: ASTKinds.LeStmt;
    id: ID;
    strt: Expr;
    end: Expr;
    step: Nullable<LeStmt_$0>;
    stmt: NonAsgnStmt;
}
export interface LeStmt_$0 {
    kind: ASTKinds.LeStmt_$0;
    step: Expr;
}
export interface DefnStmt {
    kind: ASTKinds.DefnStmt;
    idstart: PosInfo;
    id: ID;
    idend: PosInfo;
    expr: Expr;
}
export interface AssgnStmt {
    kind: ASTKinds.AssgnStmt;
    lhs: Postfix;
    op: AsgnOp;
    expr: Expr;
}
export interface GniomhStmt {
    kind: ASTKinds.GniomhStmt;
    id: ID;
    args: Nullable<CSIDs>;
    stmts: AsgnStmt[];
}
export interface CtlchStmt {
    kind: ASTKinds.CtlchStmt;
    id: ID;
    tuis: Nullable<CtlchStmt_$0>;
    gniomhs: GniomhStmt[];
}
export interface CtlchStmt_$0 {
    kind: ASTKinds.CtlchStmt_$0;
    parentstart: PosInfo;
    id: ID;
    parentend: PosInfo;
}
export interface BrisStmt {
    kind: ASTKinds.BrisStmt;
}
export interface CCStmt {
    kind: ASTKinds.CCStmt;
}
export interface ToradhStmt {
    kind: ASTKinds.ToradhStmt;
    exp: Nullable<Expr>;
}
export type Expr = And;
export class And {
    public kind: ASTKinds.And = ASTKinds.And;
    public head: Or;
    public tail: And_$0[];
    public evalfn: EvalFn;
    public qeval: Quick.MaybeEv;
    constructor(head: Or, tail: And_$0[]){
        this.head = head;
        this.tail = tail;
        this.evalfn = (() => {
        return andBinOp(this);
        })();
        this.qeval = (() => {
        return andQuickBinOp(this);
        })();
    }
}
export interface And_$0 {
    kind: ASTKinds.And_$0;
    trm: Or;
}
export class Or {
    public kind: ASTKinds.Or = ASTKinds.Or;
    public head: Eq;
    public tail: Or_$0[];
    public evalfn: EvalFn;
    public qeval: Quick.MaybeEv;
    constructor(head: Eq, tail: Or_$0[]){
        this.head = head;
        this.tail = tail;
        this.evalfn = (() => {
        return orBinOp(this)
        })();
        this.qeval = (() => {
        return orQuickBinOp(this);
        })();
    }
}
export interface Or_$0 {
    kind: ASTKinds.Or_$0;
    trm: Eq;
}
export class Eq {
    public kind: ASTKinds.Eq = ASTKinds.Eq;
    public head: Comp;
    public tail: Eq_$0[];
    public evalfn: EvalFn;
    public qeval: Quick.MaybeEv;
    constructor(head: Comp, tail: Eq_$0[]){
        this.head = head;
        this.tail = tail;
        this.evalfn = (() => {
        return binOpEvalFn(this)
        })();
        this.qeval = (() => {
        return binOpQuickEvalFn(this);
        })();
    }
}
export interface Eq_$0 {
    kind: ASTKinds.Eq_$0;
    op: string;
    trm: Comp;
}
export class Comp {
    public kind: ASTKinds.Comp = ASTKinds.Comp;
    public head: Sum;
    public tail: Comp_$0[];
    public evalfn: EvalFn;
    public qeval: Quick.MaybeEv;
    constructor(head: Sum, tail: Comp_$0[]){
        this.head = head;
        this.tail = tail;
        this.evalfn = (() => {
        return binOpEvalFn(this)
        })();
        this.qeval = (() => {
        return binOpQuickEvalFn(this);
        })();
    }
}
export interface Comp_$0 {
    kind: ASTKinds.Comp_$0;
    op: Compare;
    trm: Sum;
}
export class Sum {
    public kind: ASTKinds.Sum = ASTKinds.Sum;
    public head: Product;
    public tail: Sum_$0[];
    public evalfn: EvalFn;
    public qeval: Quick.MaybeEv;
    constructor(head: Product, tail: Sum_$0[]){
        this.head = head;
        this.tail = tail;
        this.evalfn = (() => {
        return binOpEvalFn(this)
        })();
        this.qeval = (() => {
        return binOpQuickEvalFn(this);
        })();
    }
}
export interface Sum_$0 {
    kind: ASTKinds.Sum_$0;
    op: PlusMinus;
    trm: Product;
}
export class Product {
    public kind: ASTKinds.Product = ASTKinds.Product;
    public head: Prefix;
    public tail: Product_$0[];
    public evalfn: EvalFn;
    public qeval: Quick.MaybeEv;
    constructor(head: Prefix, tail: Product_$0[]){
        this.head = head;
        this.tail = tail;
        this.evalfn = (() => {
        return binOpEvalFn(this);
        })();
        this.qeval = (() => {
        return binOpQuickEvalFn(this);
        })();
    }
}
export interface Product_$0 {
    kind: ASTKinds.Product_$0;
    op: MulDiv;
    trm: Prefix;
}
export class Prefix {
    public kind: ASTKinds.Prefix = ASTKinds.Prefix;
    public op: Nullable<string>;
    public pf: Postfix;
    public evalfn: EvalFn;
    public qeval: Quick.MaybeEv;
    constructor(op: Nullable<string>, pf: Postfix){
        this.op = op;
        this.pf = pf;
        this.evalfn = (() => {
        return prefEval(this);
        })();
        this.qeval = (() => {
        return Quick.qPrefEval(this);
        })();
    }
}
export class Postfix {
    public kind: ASTKinds.Postfix = ASTKinds.Postfix;
    public start: PosInfo;
    public at: ObjLookups;
    public ops: PostOp[];
    public end: PosInfo;
    public evalfn: EvalFn;
    public qeval: Quick.MaybeEv;
    constructor(start: PosInfo, at: ObjLookups, ops: PostOp[], end: PosInfo){
        this.start = start;
        this.at = at;
        this.ops = ops;
        this.end = end;
        this.evalfn = (() => {
        return postfixArgsEval(this);
        })();
        this.qeval = (() => {
        return Quick.qPostfixArgsEval(this);
        })();
    }
}
export class ObjLookups {
    public kind: ASTKinds.ObjLookups = ASTKinds.ObjLookups;
    public attrs: ObjLookups_$0[];
    public root: Atom;
    public evalfn: EvalFn;
    public qeval: Quick.MaybeEv;
    constructor(attrs: ObjLookups_$0[], root: Atom){
        this.attrs = attrs;
        this.root = root;
        this.evalfn = (() => {
        return objLookupsEval(this);
        })();
        this.qeval = (() => {
        return Quick.qObjLookupsEval(this);
        })();
    }
}
export interface ObjLookups_$0 {
    kind: ASTKinds.ObjLookups_$0;
    id: ID;
}
export type PostOp = PostOp_1 | PostOp_2;
export interface PostOp_1 {
    kind: ASTKinds.PostOp_1;
    args: Nullable<CSArgs>;
}
export interface PostOp_2 {
    kind: ASTKinds.PostOp_2;
    expr: Expr;
}
export type Atom = Atom_1 | Atom_2 | Atom_3 | Atom_4 | Atom_5 | Atom_6 | Atom_7;
export class Atom_1 {
    public kind: ASTKinds.Atom_1 = ASTKinds.Atom_1;
    public trm: Expr;
    public evalfn: EvalFn;
    public qeval: Quick.MaybeEv;
    constructor(trm: Expr){
        this.trm = trm;
        this.evalfn = (() => {
        return (env: Environment) => this.trm.evalfn(env);
        })();
        this.qeval = (() => {
        const childF = this.trm.qeval;
                    return childF === null ? null : childF.bind(this.trm);
        })();
    }
}
export type Atom_2 = ID;
export type Atom_3 = Litreacha;
export type Atom_4 = Int;
export type Atom_5 = Bool;
export type Atom_6 = Neamhni;
export type Atom_7 = ListLit;
export class ListLit {
    public kind: ASTKinds.ListLit = ASTKinds.ListLit;
    public els: Nullable<CSArgs>;
    public evalfn: EvalFn;
    public qeval: Quick.MaybeEv;
    constructor(els: Nullable<CSArgs>){
        this.els = els;
        this.evalfn = (() => {
        return (env: Environment) => this.els ? this.els.evalfn(env) : Promise.resolve([]);
        })();
        this.qeval = (() => {
        return Quick.qListLitEval(this);
        })();
    }
}
export class CSArgs {
    public kind: ASTKinds.CSArgs = ASTKinds.CSArgs;
    public head: Expr;
    public tail: CSArgs_$0[];
    public evalfn: (env:Environment)=>Promise<Value[]>;
    public qeval: ((env:Environment)=>Value[])|null;
    constructor(head: Expr, tail: CSArgs_$0[]){
        this.head = head;
        this.tail = tail;
        this.evalfn = (() => {
        return csArgsEval(this);
        })();
        this.qeval = (() => {
        return Quick.qCSArgsEval(this);
        })();
    }
}
export interface CSArgs_$0 {
    kind: ASTKinds.CSArgs_$0;
    exp: Expr;
}
export interface CSIDs {
    kind: ASTKinds.CSIDs;
    head: ID;
    tail: CSIDs_$0[];
}
export interface CSIDs_$0 {
    kind: ASTKinds.CSIDs_$0;
    id: ID;
}
export class ID {
    public kind: ASTKinds.ID = ASTKinds.ID;
    public id: string;
    public evalfn: EvalFn;
    public qeval: Quick.EvalFn;
    constructor(id: string){
        this.id = id;
        this.evalfn = (() => {
        return qEvalToEval(Quick.qIdEval(this.id));
        })();
        this.qeval = (() => {
        return Quick.qIdEval(this.id);
        })();
    }
}
export interface ID_$0 {
    kind: ASTKinds.ID_$0;
}
export class Bool {
    public kind: ASTKinds.Bool = ASTKinds.Bool;
    public bool: string;
    public evalfn: EvalFn;
    public qeval: Quick.EvalFn;
    constructor(bool: string){
        this.bool = bool;
        this.evalfn = (() => {
        return qEvalToEval(Quick.qBoolEval(this.bool));
        })();
        this.qeval = (() => {
        return Quick.qBoolEval(this.bool);
        })();
    }
}
export class Neamhni {
    public kind: ASTKinds.Neamhni = ASTKinds.Neamhni;
    public evalfn: EvalFn;
    public qeval: Quick.EvalFn;
    constructor(){
        this.evalfn = (() => {
        return () => Promise.resolve(null);
        })();
        this.qeval = (() => {
        return () => null;
        })();
    }
}
export class Int {
    public kind: ASTKinds.Int = ASTKinds.Int;
    public int: string;
    public evalfn: EvalFn;
    public qeval: Quick.EvalFn;
    constructor(int: string){
        this.int = int;
        this.evalfn = (() => {
        return qEvalToEval(Quick.qIntEval(this.int));
        })();
        this.qeval = (() => {
        return Quick.qIntEval(this.int);
        })();
    }
}
export class Litreacha {
    public kind: ASTKinds.Litreacha = ASTKinds.Litreacha;
    public val: string;
    public evalfn: EvalFn;
    public qeval: Quick.EvalFn;
    constructor(val: string){
        this.val = val;
        this.evalfn = (() => {
        return qEvalToEval(Quick.qLitreachaEval(this.val));
        })();
        this.qeval = (() => {
        return Quick.qLitreachaEval(this.val);
        })();
    }
}
export type _ = wspace[];
export type wspace = string;
export type gap = gap_1 | gap_2;
export type gap_1 = gap_$0[];
export type gap_2 = string;
export type gap_$0 = gap_$0_1 | gap_$0_2;
export type gap_$0_1 = wspace;
export type gap_$0_2 = string;
export type PlusMinus = string;
export type AsgnOp = string;
export type MulDiv = string;
export type Compare = string;
export type Keyword = Keyword_1 | Keyword_2 | Keyword_3 | Keyword_4 | Keyword_5 | Keyword_6 | Keyword_7 | Keyword_8 | Keyword_9;
export type Keyword_1 = string;
export type Keyword_2 = string;
export type Keyword_3 = string;
export type Keyword_4 = string;
export type Keyword_5 = string;
export type Keyword_6 = string;
export type Keyword_7 = string;
export type Keyword_8 = string;
export type Keyword_9 = string;
export class Parser {
    private readonly input: string;
    private pos: PosInfo;
    private negating: boolean = false;
    constructor(input: string) {
        this.pos = {overallPos: 0, line: 1, offset: 0};
        this.input = input;
    }
    public reset(pos: PosInfo) {
        this.pos = pos;
    }
    public finished(): boolean {
        return this.pos.overallPos === this.input.length;
    }
    public matchProgram($$dpth: number, cr?: ContextRecorder): Nullable<Program> {
        return this.runner<Program>($$dpth,
            (log) => {
                if (log) {
                    log("Program");
                }
                let stmts: Nullable<AsgnStmt[]>;
                let res: Nullable<Program> = null;
                if (true
                    && (stmts = this.loop<AsgnStmt>(() => this.matchAsgnStmt($$dpth + 1, cr), true)) !== null
                    && this.match_($$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.Program, stmts};
                }
                return res;
            }, cr)();
    }
    public matchAsgnStmt($$dpth: number, cr?: ContextRecorder): Nullable<AsgnStmt> {
        return this.choice<AsgnStmt>([
            () => this.matchAsgnStmt_1($$dpth + 1, cr),
            () => this.matchAsgnStmt_2($$dpth + 1, cr),
            () => this.matchAsgnStmt_3($$dpth + 1, cr),
            () => this.matchAsgnStmt_4($$dpth + 1, cr),
            () => this.matchAsgnStmt_5($$dpth + 1, cr),
            () => this.matchAsgnStmt_6($$dpth + 1, cr),
            () => this.matchAsgnStmt_7($$dpth + 1, cr),
            () => this.matchAsgnStmt_8($$dpth + 1, cr),
            () => this.matchAsgnStmt_9($$dpth + 1, cr),
            () => this.matchAsgnStmt_10($$dpth + 1, cr),
            () => this.matchAsgnStmt_11($$dpth + 1, cr),
            () => this.matchAsgnStmt_12($$dpth + 1, cr),
        ]);
    }
    public matchAsgnStmt_1($$dpth: number, cr?: ContextRecorder): Nullable<AsgnStmt_1> {
        return this.matchIfStmt($$dpth + 1, cr);
    }
    public matchAsgnStmt_2($$dpth: number, cr?: ContextRecorder): Nullable<AsgnStmt_2> {
        return this.matchBlockStmt($$dpth + 1, cr);
    }
    public matchAsgnStmt_3($$dpth: number, cr?: ContextRecorder): Nullable<AsgnStmt_3> {
        return this.matchNuairStmt($$dpth + 1, cr);
    }
    public matchAsgnStmt_4($$dpth: number, cr?: ContextRecorder): Nullable<AsgnStmt_4> {
        return this.matchLeStmt($$dpth + 1, cr);
    }
    public matchAsgnStmt_5($$dpth: number, cr?: ContextRecorder): Nullable<AsgnStmt_5> {
        return this.matchCCStmt($$dpth + 1, cr);
    }
    public matchAsgnStmt_6($$dpth: number, cr?: ContextRecorder): Nullable<AsgnStmt_6> {
        return this.matchBrisStmt($$dpth + 1, cr);
    }
    public matchAsgnStmt_7($$dpth: number, cr?: ContextRecorder): Nullable<AsgnStmt_7> {
        return this.matchCtlchStmt($$dpth + 1, cr);
    }
    public matchAsgnStmt_8($$dpth: number, cr?: ContextRecorder): Nullable<AsgnStmt_8> {
        return this.matchGniomhStmt($$dpth + 1, cr);
    }
    public matchAsgnStmt_9($$dpth: number, cr?: ContextRecorder): Nullable<AsgnStmt_9> {
        return this.matchToradhStmt($$dpth + 1, cr);
    }
    public matchAsgnStmt_10($$dpth: number, cr?: ContextRecorder): Nullable<AsgnStmt_10> {
        return this.matchAssgnStmt($$dpth + 1, cr);
    }
    public matchAsgnStmt_11($$dpth: number, cr?: ContextRecorder): Nullable<AsgnStmt_11> {
        return this.matchDefnStmt($$dpth + 1, cr);
    }
    public matchAsgnStmt_12($$dpth: number, cr?: ContextRecorder): Nullable<AsgnStmt_12> {
        return this.matchExpr($$dpth + 1, cr);
    }
    public matchNonAsgnStmt($$dpth: number, cr?: ContextRecorder): Nullable<NonAsgnStmt> {
        return this.choice<NonAsgnStmt>([
            () => this.matchNonAsgnStmt_1($$dpth + 1, cr),
            () => this.matchNonAsgnStmt_2($$dpth + 1, cr),
            () => this.matchNonAsgnStmt_3($$dpth + 1, cr),
            () => this.matchNonAsgnStmt_4($$dpth + 1, cr),
            () => this.matchNonAsgnStmt_5($$dpth + 1, cr),
            () => this.matchNonAsgnStmt_6($$dpth + 1, cr),
            () => this.matchNonAsgnStmt_7($$dpth + 1, cr),
            () => this.matchNonAsgnStmt_8($$dpth + 1, cr),
            () => this.matchNonAsgnStmt_9($$dpth + 1, cr),
        ]);
    }
    public matchNonAsgnStmt_1($$dpth: number, cr?: ContextRecorder): Nullable<NonAsgnStmt_1> {
        return this.matchIfStmt($$dpth + 1, cr);
    }
    public matchNonAsgnStmt_2($$dpth: number, cr?: ContextRecorder): Nullable<NonAsgnStmt_2> {
        return this.matchNuairStmt($$dpth + 1, cr);
    }
    public matchNonAsgnStmt_3($$dpth: number, cr?: ContextRecorder): Nullable<NonAsgnStmt_3> {
        return this.matchLeStmt($$dpth + 1, cr);
    }
    public matchNonAsgnStmt_4($$dpth: number, cr?: ContextRecorder): Nullable<NonAsgnStmt_4> {
        return this.matchCCStmt($$dpth + 1, cr);
    }
    public matchNonAsgnStmt_5($$dpth: number, cr?: ContextRecorder): Nullable<NonAsgnStmt_5> {
        return this.matchBrisStmt($$dpth + 1, cr);
    }
    public matchNonAsgnStmt_6($$dpth: number, cr?: ContextRecorder): Nullable<NonAsgnStmt_6> {
        return this.matchToradhStmt($$dpth + 1, cr);
    }
    public matchNonAsgnStmt_7($$dpth: number, cr?: ContextRecorder): Nullable<NonAsgnStmt_7> {
        return this.matchBlockStmt($$dpth + 1, cr);
    }
    public matchNonAsgnStmt_8($$dpth: number, cr?: ContextRecorder): Nullable<NonAsgnStmt_8> {
        return this.matchAssgnStmt($$dpth + 1, cr);
    }
    public matchNonAsgnStmt_9($$dpth: number, cr?: ContextRecorder): Nullable<NonAsgnStmt_9> {
        return this.matchExpr($$dpth + 1, cr);
    }
    public matchIfStmt($$dpth: number, cr?: ContextRecorder): Nullable<IfStmt> {
        return this.runner<IfStmt>($$dpth,
            (log) => {
                if (log) {
                    log("IfStmt");
                }
                let expr: Nullable<Expr>;
                let stmt: Nullable<NonAsgnStmt>;
                let elsebranch: Nullable<Nullable<IfStmt_$0>>;
                let res: Nullable<IfStmt> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`m[áa]`, $$dpth + 1, cr) !== null
                    && this.noConsume<gap>(() => this.matchgap($$dpth + 1, cr)) !== null
                    && (expr = this.matchExpr($$dpth + 1, cr)) !== null
                    && this.noConsume<gap>(() => this.matchgap($$dpth + 1, cr)) !== null
                    && (stmt = this.matchNonAsgnStmt($$dpth + 1, cr)) !== null
                    && ((elsebranch = this.matchIfStmt_$0($$dpth + 1, cr)) || true)
                ) {
                    res = {kind: ASTKinds.IfStmt, expr, stmt, elsebranch};
                }
                return res;
            }, cr)();
    }
    public matchIfStmt_$0($$dpth: number, cr?: ContextRecorder): Nullable<IfStmt_$0> {
        return this.runner<IfStmt_$0>($$dpth,
            (log) => {
                if (log) {
                    log("IfStmt_$0");
                }
                let stmt: Nullable<NonAsgnStmt>;
                let res: Nullable<IfStmt_$0> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`n[oó]`, $$dpth + 1, cr) !== null
                    && this.noConsume<gap>(() => this.matchgap($$dpth + 1, cr)) !== null
                    && (stmt = this.matchNonAsgnStmt($$dpth + 1, cr)) !== null
                ) {
                    res = {kind: ASTKinds.IfStmt_$0, stmt};
                }
                return res;
            }, cr)();
    }
    public matchBlockStmt($$dpth: number, cr?: ContextRecorder): Nullable<BlockStmt> {
        return this.runner<BlockStmt>($$dpth,
            (log) => {
                if (log) {
                    log("BlockStmt");
                }
                let blk: Nullable<AsgnStmt[]>;
                let res: Nullable<BlockStmt> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`{`, $$dpth + 1, cr) !== null
                    && (blk = this.loop<AsgnStmt>(() => this.matchAsgnStmt($$dpth + 1, cr), true)) !== null
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`}`, $$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.BlockStmt, blk};
                }
                return res;
            }, cr)();
    }
    public matchNuairStmt($$dpth: number, cr?: ContextRecorder): Nullable<NuairStmt> {
        return this.runner<NuairStmt>($$dpth,
            (log) => {
                if (log) {
                    log("NuairStmt");
                }
                let expr: Nullable<Expr>;
                let stmt: Nullable<NonAsgnStmt>;
                let res: Nullable<NuairStmt> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`nuair-a`, $$dpth + 1, cr) !== null
                    && (expr = this.matchExpr($$dpth + 1, cr)) !== null
                    && this.noConsume<gap>(() => this.matchgap($$dpth + 1, cr)) !== null
                    && (stmt = this.matchNonAsgnStmt($$dpth + 1, cr)) !== null
                ) {
                    res = {kind: ASTKinds.NuairStmt, expr, stmt};
                }
                return res;
            }, cr)();
    }
    public matchLeStmt($$dpth: number, cr?: ContextRecorder): Nullable<LeStmt> {
        return this.runner<LeStmt>($$dpth,
            (log) => {
                if (log) {
                    log("LeStmt");
                }
                let id: Nullable<ID>;
                let strt: Nullable<Expr>;
                let end: Nullable<Expr>;
                let step: Nullable<Nullable<LeStmt_$0>>;
                let stmt: Nullable<NonAsgnStmt>;
                let res: Nullable<LeStmt> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`le`, $$dpth + 1, cr) !== null
                    && this.noConsume<gap>(() => this.matchgap($$dpth + 1, cr)) !== null
                    && (id = this.matchID($$dpth + 1, cr)) !== null
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`idir`, $$dpth + 1, cr) !== null
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`\(`, $$dpth + 1, cr) !== null
                    && (strt = this.matchExpr($$dpth + 1, cr)) !== null
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`,`, $$dpth + 1, cr) !== null
                    && (end = this.matchExpr($$dpth + 1, cr)) !== null
                    && ((step = this.matchLeStmt_$0($$dpth + 1, cr)) || true)
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`\)`, $$dpth + 1, cr) !== null
                    && (stmt = this.matchNonAsgnStmt($$dpth + 1, cr)) !== null
                ) {
                    res = {kind: ASTKinds.LeStmt, id, strt, end, step, stmt};
                }
                return res;
            }, cr)();
    }
    public matchLeStmt_$0($$dpth: number, cr?: ContextRecorder): Nullable<LeStmt_$0> {
        return this.runner<LeStmt_$0>($$dpth,
            (log) => {
                if (log) {
                    log("LeStmt_$0");
                }
                let step: Nullable<Expr>;
                let res: Nullable<LeStmt_$0> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`,`, $$dpth + 1, cr) !== null
                    && (step = this.matchExpr($$dpth + 1, cr)) !== null
                ) {
                    res = {kind: ASTKinds.LeStmt_$0, step};
                }
                return res;
            }, cr)();
    }
    public matchDefnStmt($$dpth: number, cr?: ContextRecorder): Nullable<DefnStmt> {
        return this.runner<DefnStmt>($$dpth,
            (log) => {
                if (log) {
                    log("DefnStmt");
                }
                let idstart: Nullable<PosInfo>;
                let id: Nullable<ID>;
                let idend: Nullable<PosInfo>;
                let expr: Nullable<Expr>;
                let res: Nullable<DefnStmt> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && (idstart = this.mark()) !== null
                    && (id = this.matchID($$dpth + 1, cr)) !== null
                    && (idend = this.mark()) !== null
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`:=`, $$dpth + 1, cr) !== null
                    && this.match_($$dpth + 1, cr) !== null
                    && (expr = this.matchExpr($$dpth + 1, cr)) !== null
                ) {
                    res = {kind: ASTKinds.DefnStmt, idstart, id, idend, expr};
                }
                return res;
            }, cr)();
    }
    public matchAssgnStmt($$dpth: number, cr?: ContextRecorder): Nullable<AssgnStmt> {
        return this.runner<AssgnStmt>($$dpth,
            (log) => {
                if (log) {
                    log("AssgnStmt");
                }
                let lhs: Nullable<Postfix>;
                let op: Nullable<AsgnOp>;
                let expr: Nullable<Expr>;
                let res: Nullable<AssgnStmt> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && (lhs = this.matchPostfix($$dpth + 1, cr)) !== null
                    && this.match_($$dpth + 1, cr) !== null
                    && (op = this.matchAsgnOp($$dpth + 1, cr)) !== null
                    && this.match_($$dpth + 1, cr) !== null
                    && (expr = this.matchExpr($$dpth + 1, cr)) !== null
                ) {
                    res = {kind: ASTKinds.AssgnStmt, lhs, op, expr};
                }
                return res;
            }, cr)();
    }
    public matchGniomhStmt($$dpth: number, cr?: ContextRecorder): Nullable<GniomhStmt> {
        return this.runner<GniomhStmt>($$dpth,
            (log) => {
                if (log) {
                    log("GniomhStmt");
                }
                let id: Nullable<ID>;
                let args: Nullable<Nullable<CSIDs>>;
                let stmts: Nullable<AsgnStmt[]>;
                let res: Nullable<GniomhStmt> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`gn[íi]omh`, $$dpth + 1, cr) !== null
                    && this.noConsume<gap>(() => this.matchgap($$dpth + 1, cr)) !== null
                    && (id = this.matchID($$dpth + 1, cr)) !== null
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`\(`, $$dpth + 1, cr) !== null
                    && ((args = this.matchCSIDs($$dpth + 1, cr)) || true)
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`\)`, $$dpth + 1, cr) !== null
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`{`, $$dpth + 1, cr) !== null
                    && (stmts = this.loop<AsgnStmt>(() => this.matchAsgnStmt($$dpth + 1, cr), true)) !== null
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`}`, $$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.GniomhStmt, id, args, stmts};
                }
                return res;
            }, cr)();
    }
    public matchCtlchStmt($$dpth: number, cr?: ContextRecorder): Nullable<CtlchStmt> {
        return this.runner<CtlchStmt>($$dpth,
            (log) => {
                if (log) {
                    log("CtlchStmt");
                }
                let id: Nullable<ID>;
                let tuis: Nullable<Nullable<CtlchStmt_$0>>;
                let gniomhs: Nullable<GniomhStmt[]>;
                let res: Nullable<CtlchStmt> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`creatlach`, $$dpth + 1, cr) !== null
                    && this.noConsume<gap>(() => this.matchgap($$dpth + 1, cr)) !== null
                    && (id = this.matchID($$dpth + 1, cr)) !== null
                    && ((tuis = this.matchCtlchStmt_$0($$dpth + 1, cr)) || true)
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`{`, $$dpth + 1, cr) !== null
                    && (gniomhs = this.loop<GniomhStmt>(() => this.matchGniomhStmt($$dpth + 1, cr), true)) !== null
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`}`, $$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.CtlchStmt, id, tuis, gniomhs};
                }
                return res;
            }, cr)();
    }
    public matchCtlchStmt_$0($$dpth: number, cr?: ContextRecorder): Nullable<CtlchStmt_$0> {
        return this.runner<CtlchStmt_$0>($$dpth,
            (log) => {
                if (log) {
                    log("CtlchStmt_$0");
                }
                let parentstart: Nullable<PosInfo>;
                let id: Nullable<ID>;
                let parentend: Nullable<PosInfo>;
                let res: Nullable<CtlchStmt_$0> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`ó`, $$dpth + 1, cr) !== null
                    && this.noConsume<gap>(() => this.matchgap($$dpth + 1, cr)) !== null
                    && (parentstart = this.mark()) !== null
                    && (id = this.matchID($$dpth + 1, cr)) !== null
                    && (parentend = this.mark()) !== null
                ) {
                    res = {kind: ASTKinds.CtlchStmt_$0, parentstart, id, parentend};
                }
                return res;
            }, cr)();
    }
    public matchBrisStmt($$dpth: number, cr?: ContextRecorder): Nullable<BrisStmt> {
        return this.runner<BrisStmt>($$dpth,
            (log) => {
                if (log) {
                    log("BrisStmt");
                }
                let res: Nullable<BrisStmt> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`bris`, $$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.BrisStmt, };
                }
                return res;
            }, cr)();
    }
    public matchCCStmt($$dpth: number, cr?: ContextRecorder): Nullable<CCStmt> {
        return this.runner<CCStmt>($$dpth,
            (log) => {
                if (log) {
                    log("CCStmt");
                }
                let res: Nullable<CCStmt> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`chun-cinn`, $$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.CCStmt, };
                }
                return res;
            }, cr)();
    }
    public matchToradhStmt($$dpth: number, cr?: ContextRecorder): Nullable<ToradhStmt> {
        return this.runner<ToradhStmt>($$dpth,
            (log) => {
                if (log) {
                    log("ToradhStmt");
                }
                let exp: Nullable<Nullable<Expr>>;
                let res: Nullable<ToradhStmt> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`toradh`, $$dpth + 1, cr) !== null
                    && this.noConsume<gap>(() => this.matchgap($$dpth + 1, cr)) !== null
                    && ((exp = this.matchExpr($$dpth + 1, cr)) || true)
                ) {
                    res = {kind: ASTKinds.ToradhStmt, exp};
                }
                return res;
            }, cr)();
    }
    public matchExpr($$dpth: number, cr?: ContextRecorder): Nullable<Expr> {
        return this.matchAnd($$dpth + 1, cr);
    }
    public matchAnd($$dpth: number, cr?: ContextRecorder): Nullable<And> {
        return this.runner<And>($$dpth,
            (log) => {
                if (log) {
                    log("And");
                }
                let head: Nullable<Or>;
                let tail: Nullable<And_$0[]>;
                let res: Nullable<And> = null;
                if (true
                    && (head = this.matchOr($$dpth + 1, cr)) !== null
                    && (tail = this.loop<And_$0>(() => this.matchAnd_$0($$dpth + 1, cr), true)) !== null
                ) {
                    res = new And(head, tail);
                }
                return res;
            }, cr)();
    }
    public matchAnd_$0($$dpth: number, cr?: ContextRecorder): Nullable<And_$0> {
        return this.runner<And_$0>($$dpth,
            (log) => {
                if (log) {
                    log("And_$0");
                }
                let trm: Nullable<Or>;
                let res: Nullable<And_$0> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`\&`, $$dpth + 1, cr) !== null
                    && (trm = this.matchOr($$dpth + 1, cr)) !== null
                ) {
                    res = {kind: ASTKinds.And_$0, trm};
                }
                return res;
            }, cr)();
    }
    public matchOr($$dpth: number, cr?: ContextRecorder): Nullable<Or> {
        return this.runner<Or>($$dpth,
            (log) => {
                if (log) {
                    log("Or");
                }
                let head: Nullable<Eq>;
                let tail: Nullable<Or_$0[]>;
                let res: Nullable<Or> = null;
                if (true
                    && (head = this.matchEq($$dpth + 1, cr)) !== null
                    && (tail = this.loop<Or_$0>(() => this.matchOr_$0($$dpth + 1, cr), true)) !== null
                ) {
                    res = new Or(head, tail);
                }
                return res;
            }, cr)();
    }
    public matchOr_$0($$dpth: number, cr?: ContextRecorder): Nullable<Or_$0> {
        return this.runner<Or_$0>($$dpth,
            (log) => {
                if (log) {
                    log("Or_$0");
                }
                let trm: Nullable<Eq>;
                let res: Nullable<Or_$0> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`\|`, $$dpth + 1, cr) !== null
                    && (trm = this.matchEq($$dpth + 1, cr)) !== null
                ) {
                    res = {kind: ASTKinds.Or_$0, trm};
                }
                return res;
            }, cr)();
    }
    public matchEq($$dpth: number, cr?: ContextRecorder): Nullable<Eq> {
        return this.runner<Eq>($$dpth,
            (log) => {
                if (log) {
                    log("Eq");
                }
                let head: Nullable<Comp>;
                let tail: Nullable<Eq_$0[]>;
                let res: Nullable<Eq> = null;
                if (true
                    && (head = this.matchComp($$dpth + 1, cr)) !== null
                    && (tail = this.loop<Eq_$0>(() => this.matchEq_$0($$dpth + 1, cr), true)) !== null
                ) {
                    res = new Eq(head, tail);
                }
                return res;
            }, cr)();
    }
    public matchEq_$0($$dpth: number, cr?: ContextRecorder): Nullable<Eq_$0> {
        return this.runner<Eq_$0>($$dpth,
            (log) => {
                if (log) {
                    log("Eq_$0");
                }
                let op: Nullable<string>;
                let trm: Nullable<Comp>;
                let res: Nullable<Eq_$0> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && (op = this.regexAccept(String.raw`[!=]=`, $$dpth + 1, cr)) !== null
                    && (trm = this.matchComp($$dpth + 1, cr)) !== null
                ) {
                    res = {kind: ASTKinds.Eq_$0, op, trm};
                }
                return res;
            }, cr)();
    }
    public matchComp($$dpth: number, cr?: ContextRecorder): Nullable<Comp> {
        return this.runner<Comp>($$dpth,
            (log) => {
                if (log) {
                    log("Comp");
                }
                let head: Nullable<Sum>;
                let tail: Nullable<Comp_$0[]>;
                let res: Nullable<Comp> = null;
                if (true
                    && (head = this.matchSum($$dpth + 1, cr)) !== null
                    && (tail = this.loop<Comp_$0>(() => this.matchComp_$0($$dpth + 1, cr), true)) !== null
                ) {
                    res = new Comp(head, tail);
                }
                return res;
            }, cr)();
    }
    public matchComp_$0($$dpth: number, cr?: ContextRecorder): Nullable<Comp_$0> {
        return this.runner<Comp_$0>($$dpth,
            (log) => {
                if (log) {
                    log("Comp_$0");
                }
                let op: Nullable<Compare>;
                let trm: Nullable<Sum>;
                let res: Nullable<Comp_$0> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && (op = this.matchCompare($$dpth + 1, cr)) !== null
                    && (trm = this.matchSum($$dpth + 1, cr)) !== null
                ) {
                    res = {kind: ASTKinds.Comp_$0, op, trm};
                }
                return res;
            }, cr)();
    }
    public matchSum($$dpth: number, cr?: ContextRecorder): Nullable<Sum> {
        return this.runner<Sum>($$dpth,
            (log) => {
                if (log) {
                    log("Sum");
                }
                let head: Nullable<Product>;
                let tail: Nullable<Sum_$0[]>;
                let res: Nullable<Sum> = null;
                if (true
                    && (head = this.matchProduct($$dpth + 1, cr)) !== null
                    && (tail = this.loop<Sum_$0>(() => this.matchSum_$0($$dpth + 1, cr), true)) !== null
                ) {
                    res = new Sum(head, tail);
                }
                return res;
            }, cr)();
    }
    public matchSum_$0($$dpth: number, cr?: ContextRecorder): Nullable<Sum_$0> {
        return this.runner<Sum_$0>($$dpth,
            (log) => {
                if (log) {
                    log("Sum_$0");
                }
                let op: Nullable<PlusMinus>;
                let trm: Nullable<Product>;
                let res: Nullable<Sum_$0> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && (op = this.matchPlusMinus($$dpth + 1, cr)) !== null
                    && (trm = this.matchProduct($$dpth + 1, cr)) !== null
                ) {
                    res = {kind: ASTKinds.Sum_$0, op, trm};
                }
                return res;
            }, cr)();
    }
    public matchProduct($$dpth: number, cr?: ContextRecorder): Nullable<Product> {
        return this.runner<Product>($$dpth,
            (log) => {
                if (log) {
                    log("Product");
                }
                let head: Nullable<Prefix>;
                let tail: Nullable<Product_$0[]>;
                let res: Nullable<Product> = null;
                if (true
                    && (head = this.matchPrefix($$dpth + 1, cr)) !== null
                    && (tail = this.loop<Product_$0>(() => this.matchProduct_$0($$dpth + 1, cr), true)) !== null
                ) {
                    res = new Product(head, tail);
                }
                return res;
            }, cr)();
    }
    public matchProduct_$0($$dpth: number, cr?: ContextRecorder): Nullable<Product_$0> {
        return this.runner<Product_$0>($$dpth,
            (log) => {
                if (log) {
                    log("Product_$0");
                }
                let op: Nullable<MulDiv>;
                let trm: Nullable<Prefix>;
                let res: Nullable<Product_$0> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && (op = this.matchMulDiv($$dpth + 1, cr)) !== null
                    && (trm = this.matchPrefix($$dpth + 1, cr)) !== null
                ) {
                    res = {kind: ASTKinds.Product_$0, op, trm};
                }
                return res;
            }, cr)();
    }
    public matchPrefix($$dpth: number, cr?: ContextRecorder): Nullable<Prefix> {
        return this.runner<Prefix>($$dpth,
            (log) => {
                if (log) {
                    log("Prefix");
                }
                let op: Nullable<Nullable<string>>;
                let pf: Nullable<Postfix>;
                let res: Nullable<Prefix> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && ((op = this.regexAccept(String.raw`-|!`, $$dpth + 1, cr)) || true)
                    && (pf = this.matchPostfix($$dpth + 1, cr)) !== null
                ) {
                    res = new Prefix(op, pf);
                }
                return res;
            }, cr)();
    }
    public matchPostfix($$dpth: number, cr?: ContextRecorder): Nullable<Postfix> {
        return this.runner<Postfix>($$dpth,
            (log) => {
                if (log) {
                    log("Postfix");
                }
                let start: Nullable<PosInfo>;
                let at: Nullable<ObjLookups>;
                let ops: Nullable<PostOp[]>;
                let end: Nullable<PosInfo>;
                let res: Nullable<Postfix> = null;
                if (true
                    && (start = this.mark()) !== null
                    && (at = this.matchObjLookups($$dpth + 1, cr)) !== null
                    && (ops = this.loop<PostOp>(() => this.matchPostOp($$dpth + 1, cr), true)) !== null
                    && (end = this.mark()) !== null
                ) {
                    res = new Postfix(start, at, ops, end);
                }
                return res;
            }, cr)();
    }
    public matchObjLookups($$dpth: number, cr?: ContextRecorder): Nullable<ObjLookups> {
        return this.runner<ObjLookups>($$dpth,
            (log) => {
                if (log) {
                    log("ObjLookups");
                }
                let attrs: Nullable<ObjLookups_$0[]>;
                let root: Nullable<Atom>;
                let res: Nullable<ObjLookups> = null;
                if (true
                    && (attrs = this.loop<ObjLookups_$0>(() => this.matchObjLookups_$0($$dpth + 1, cr), true)) !== null
                    && (root = this.matchAtom($$dpth + 1, cr)) !== null
                ) {
                    res = new ObjLookups(attrs, root);
                }
                return res;
            }, cr)();
    }
    public matchObjLookups_$0($$dpth: number, cr?: ContextRecorder): Nullable<ObjLookups_$0> {
        return this.runner<ObjLookups_$0>($$dpth,
            (log) => {
                if (log) {
                    log("ObjLookups_$0");
                }
                let id: Nullable<ID>;
                let res: Nullable<ObjLookups_$0> = null;
                if (true
                    && (id = this.matchID($$dpth + 1, cr)) !== null
                    && this.regexAccept(String.raw`@`, $$dpth + 1, cr) !== null
                    && this.negate(() => this.matchwspace($$dpth + 1, cr)) !== null
                ) {
                    res = {kind: ASTKinds.ObjLookups_$0, id};
                }
                return res;
            }, cr)();
    }
    public matchPostOp($$dpth: number, cr?: ContextRecorder): Nullable<PostOp> {
        return this.choice<PostOp>([
            () => this.matchPostOp_1($$dpth + 1, cr),
            () => this.matchPostOp_2($$dpth + 1, cr),
        ]);
    }
    public matchPostOp_1($$dpth: number, cr?: ContextRecorder): Nullable<PostOp_1> {
        return this.runner<PostOp_1>($$dpth,
            (log) => {
                if (log) {
                    log("PostOp_1");
                }
                let args: Nullable<Nullable<CSArgs>>;
                let res: Nullable<PostOp_1> = null;
                if (true
                    && this.regexAccept(String.raw`\(`, $$dpth + 1, cr) !== null
                    && ((args = this.matchCSArgs($$dpth + 1, cr)) || true)
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`\)`, $$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.PostOp_1, args};
                }
                return res;
            }, cr)();
    }
    public matchPostOp_2($$dpth: number, cr?: ContextRecorder): Nullable<PostOp_2> {
        return this.runner<PostOp_2>($$dpth,
            (log) => {
                if (log) {
                    log("PostOp_2");
                }
                let expr: Nullable<Expr>;
                let res: Nullable<PostOp_2> = null;
                if (true
                    && this.regexAccept(String.raw`\[`, $$dpth + 1, cr) !== null
                    && (expr = this.matchExpr($$dpth + 1, cr)) !== null
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`\]`, $$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.PostOp_2, expr};
                }
                return res;
            }, cr)();
    }
    public matchAtom($$dpth: number, cr?: ContextRecorder): Nullable<Atom> {
        return this.choice<Atom>([
            () => this.matchAtom_1($$dpth + 1, cr),
            () => this.matchAtom_2($$dpth + 1, cr),
            () => this.matchAtom_3($$dpth + 1, cr),
            () => this.matchAtom_4($$dpth + 1, cr),
            () => this.matchAtom_5($$dpth + 1, cr),
            () => this.matchAtom_6($$dpth + 1, cr),
            () => this.matchAtom_7($$dpth + 1, cr),
        ]);
    }
    public matchAtom_1($$dpth: number, cr?: ContextRecorder): Nullable<Atom_1> {
        return this.runner<Atom_1>($$dpth,
            (log) => {
                if (log) {
                    log("Atom_1");
                }
                let trm: Nullable<Expr>;
                let res: Nullable<Atom_1> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`\(`, $$dpth + 1, cr) !== null
                    && (trm = this.matchExpr($$dpth + 1, cr)) !== null
                    && this.regexAccept(String.raw`\)`, $$dpth + 1, cr) !== null
                ) {
                    res = new Atom_1(trm);
                }
                return res;
            }, cr)();
    }
    public matchAtom_2($$dpth: number, cr?: ContextRecorder): Nullable<Atom_2> {
        return this.matchID($$dpth + 1, cr);
    }
    public matchAtom_3($$dpth: number, cr?: ContextRecorder): Nullable<Atom_3> {
        return this.matchLitreacha($$dpth + 1, cr);
    }
    public matchAtom_4($$dpth: number, cr?: ContextRecorder): Nullable<Atom_4> {
        return this.matchInt($$dpth + 1, cr);
    }
    public matchAtom_5($$dpth: number, cr?: ContextRecorder): Nullable<Atom_5> {
        return this.matchBool($$dpth + 1, cr);
    }
    public matchAtom_6($$dpth: number, cr?: ContextRecorder): Nullable<Atom_6> {
        return this.matchNeamhni($$dpth + 1, cr);
    }
    public matchAtom_7($$dpth: number, cr?: ContextRecorder): Nullable<Atom_7> {
        return this.matchListLit($$dpth + 1, cr);
    }
    public matchListLit($$dpth: number, cr?: ContextRecorder): Nullable<ListLit> {
        return this.runner<ListLit>($$dpth,
            (log) => {
                if (log) {
                    log("ListLit");
                }
                let els: Nullable<Nullable<CSArgs>>;
                let res: Nullable<ListLit> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`\[`, $$dpth + 1, cr) !== null
                    && ((els = this.matchCSArgs($$dpth + 1, cr)) || true)
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`\]`, $$dpth + 1, cr) !== null
                ) {
                    res = new ListLit(els);
                }
                return res;
            }, cr)();
    }
    public matchCSArgs($$dpth: number, cr?: ContextRecorder): Nullable<CSArgs> {
        return this.runner<CSArgs>($$dpth,
            (log) => {
                if (log) {
                    log("CSArgs");
                }
                let head: Nullable<Expr>;
                let tail: Nullable<CSArgs_$0[]>;
                let res: Nullable<CSArgs> = null;
                if (true
                    && (head = this.matchExpr($$dpth + 1, cr)) !== null
                    && (tail = this.loop<CSArgs_$0>(() => this.matchCSArgs_$0($$dpth + 1, cr), true)) !== null
                ) {
                    res = new CSArgs(head, tail);
                }
                return res;
            }, cr)();
    }
    public matchCSArgs_$0($$dpth: number, cr?: ContextRecorder): Nullable<CSArgs_$0> {
        return this.runner<CSArgs_$0>($$dpth,
            (log) => {
                if (log) {
                    log("CSArgs_$0");
                }
                let exp: Nullable<Expr>;
                let res: Nullable<CSArgs_$0> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`,`, $$dpth + 1, cr) !== null
                    && (exp = this.matchExpr($$dpth + 1, cr)) !== null
                ) {
                    res = {kind: ASTKinds.CSArgs_$0, exp};
                }
                return res;
            }, cr)();
    }
    public matchCSIDs($$dpth: number, cr?: ContextRecorder): Nullable<CSIDs> {
        return this.runner<CSIDs>($$dpth,
            (log) => {
                if (log) {
                    log("CSIDs");
                }
                let head: Nullable<ID>;
                let tail: Nullable<CSIDs_$0[]>;
                let res: Nullable<CSIDs> = null;
                if (true
                    && (head = this.matchID($$dpth + 1, cr)) !== null
                    && (tail = this.loop<CSIDs_$0>(() => this.matchCSIDs_$0($$dpth + 1, cr), true)) !== null
                ) {
                    res = {kind: ASTKinds.CSIDs, head, tail};
                }
                return res;
            }, cr)();
    }
    public matchCSIDs_$0($$dpth: number, cr?: ContextRecorder): Nullable<CSIDs_$0> {
        return this.runner<CSIDs_$0>($$dpth,
            (log) => {
                if (log) {
                    log("CSIDs_$0");
                }
                let id: Nullable<ID>;
                let res: Nullable<CSIDs_$0> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`,`, $$dpth + 1, cr) !== null
                    && (id = this.matchID($$dpth + 1, cr)) !== null
                ) {
                    res = {kind: ASTKinds.CSIDs_$0, id};
                }
                return res;
            }, cr)();
    }
    public matchID($$dpth: number, cr?: ContextRecorder): Nullable<ID> {
        return this.runner<ID>($$dpth,
            (log) => {
                if (log) {
                    log("ID");
                }
                let id: Nullable<string>;
                let res: Nullable<ID> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.negate(() => this.matchID_$0($$dpth + 1, cr)) !== null
                    && (id = this.regexAccept(String.raw`[a-zA-Z_áéíóúÁÉÍÓÚ]+`, $$dpth + 1, cr)) !== null
                ) {
                    res = new ID(id);
                }
                return res;
            }, cr)();
    }
    public matchID_$0($$dpth: number, cr?: ContextRecorder): Nullable<ID_$0> {
        return this.runner<ID_$0>($$dpth,
            (log) => {
                if (log) {
                    log("ID_$0");
                }
                let res: Nullable<ID_$0> = null;
                if (true
                    && this.matchKeyword($$dpth + 1, cr) !== null
                    && this.matchgap($$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.ID_$0, };
                }
                return res;
            }, cr)();
    }
    public matchBool($$dpth: number, cr?: ContextRecorder): Nullable<Bool> {
        return this.runner<Bool>($$dpth,
            (log) => {
                if (log) {
                    log("Bool");
                }
                let bool: Nullable<string>;
                let res: Nullable<Bool> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && (bool = this.regexAccept(String.raw`f[ií]or|br[eé]ag`, $$dpth + 1, cr)) !== null
                ) {
                    res = new Bool(bool);
                }
                return res;
            }, cr)();
    }
    public matchNeamhni($$dpth: number, cr?: ContextRecorder): Nullable<Neamhni> {
        return this.runner<Neamhni>($$dpth,
            (log) => {
                if (log) {
                    log("Neamhni");
                }
                let res: Nullable<Neamhni> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`neamhn[ií]`, $$dpth + 1, cr) !== null
                ) {
                    res = new Neamhni();
                }
                return res;
            }, cr)();
    }
    public matchInt($$dpth: number, cr?: ContextRecorder): Nullable<Int> {
        return this.runner<Int>($$dpth,
            (log) => {
                if (log) {
                    log("Int");
                }
                let int: Nullable<string>;
                let res: Nullable<Int> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && (int = this.regexAccept(String.raw`-?[0-9]+(?:\.[0-9]+)?`, $$dpth + 1, cr)) !== null
                ) {
                    res = new Int(int);
                }
                return res;
            }, cr)();
    }
    public matchLitreacha($$dpth: number, cr?: ContextRecorder): Nullable<Litreacha> {
        return this.runner<Litreacha>($$dpth,
            (log) => {
                if (log) {
                    log("Litreacha");
                }
                let val: Nullable<string>;
                let res: Nullable<Litreacha> = null;
                if (true
                    && this.match_($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`\'`, $$dpth + 1, cr) !== null
                    && (val = this.regexAccept(String.raw`([^\'\\]|\\.)*`, $$dpth + 1, cr)) !== null
                    && this.regexAccept(String.raw`\'`, $$dpth + 1, cr) !== null
                ) {
                    res = new Litreacha(val);
                }
                return res;
            }, cr)();
    }
    public match_($$dpth: number, cr?: ContextRecorder): Nullable<_> {
        return this.loop<wspace>(() => this.matchwspace($$dpth + 1, cr), true);
    }
    public matchwspace($$dpth: number, cr?: ContextRecorder): Nullable<wspace> {
        return this.regexAccept(String.raw`(?:\s|>--(?:(?!--<).)*(--<|\n|$))`, $$dpth + 1, cr);
    }
    public matchgap($$dpth: number, cr?: ContextRecorder): Nullable<gap> {
        return this.choice<gap>([
            () => this.matchgap_1($$dpth + 1, cr),
            () => this.matchgap_2($$dpth + 1, cr),
        ]);
    }
    public matchgap_1($$dpth: number, cr?: ContextRecorder): Nullable<gap_1> {
        return this.loop<gap_$0>(() => this.matchgap_$0($$dpth + 1, cr), false);
    }
    public matchgap_2($$dpth: number, cr?: ContextRecorder): Nullable<gap_2> {
        return this.regexAccept(String.raw`$`, $$dpth + 1, cr);
    }
    public matchgap_$0($$dpth: number, cr?: ContextRecorder): Nullable<gap_$0> {
        return this.choice<gap_$0>([
            () => this.matchgap_$0_1($$dpth + 1, cr),
            () => this.matchgap_$0_2($$dpth + 1, cr),
        ]);
    }
    public matchgap_$0_1($$dpth: number, cr?: ContextRecorder): Nullable<gap_$0_1> {
        return this.matchwspace($$dpth + 1, cr);
    }
    public matchgap_$0_2($$dpth: number, cr?: ContextRecorder): Nullable<gap_$0_2> {
        return this.regexAccept(String.raw`[^a-zA-Z0-9áéíóúÁÉÍÓÚ]`, $$dpth + 1, cr);
    }
    public matchPlusMinus($$dpth: number, cr?: ContextRecorder): Nullable<PlusMinus> {
        return this.regexAccept(String.raw`\+|-`, $$dpth + 1, cr);
    }
    public matchAsgnOp($$dpth: number, cr?: ContextRecorder): Nullable<AsgnOp> {
        return this.regexAccept(String.raw`=|\+=|\*=|-=|%=|\/=`, $$dpth + 1, cr);
    }
    public matchMulDiv($$dpth: number, cr?: ContextRecorder): Nullable<MulDiv> {
        return this.regexAccept(String.raw`\*|\/\/|%|\/`, $$dpth + 1, cr);
    }
    public matchCompare($$dpth: number, cr?: ContextRecorder): Nullable<Compare> {
        return this.regexAccept(String.raw`<=|>=|<|>`, $$dpth + 1, cr);
    }
    public matchKeyword($$dpth: number, cr?: ContextRecorder): Nullable<Keyword> {
        return this.choice<Keyword>([
            () => this.matchKeyword_1($$dpth + 1, cr),
            () => this.matchKeyword_2($$dpth + 1, cr),
            () => this.matchKeyword_3($$dpth + 1, cr),
            () => this.matchKeyword_4($$dpth + 1, cr),
            () => this.matchKeyword_5($$dpth + 1, cr),
            () => this.matchKeyword_6($$dpth + 1, cr),
            () => this.matchKeyword_7($$dpth + 1, cr),
            () => this.matchKeyword_8($$dpth + 1, cr),
            () => this.matchKeyword_9($$dpth + 1, cr),
        ]);
    }
    public matchKeyword_1($$dpth: number, cr?: ContextRecorder): Nullable<Keyword_1> {
        return this.regexAccept(String.raw`m[áa]`, $$dpth + 1, cr);
    }
    public matchKeyword_2($$dpth: number, cr?: ContextRecorder): Nullable<Keyword_2> {
        return this.regexAccept(String.raw`n[oó]`, $$dpth + 1, cr);
    }
    public matchKeyword_3($$dpth: number, cr?: ContextRecorder): Nullable<Keyword_3> {
        return this.regexAccept(String.raw`nuair-a`, $$dpth + 1, cr);
    }
    public matchKeyword_4($$dpth: number, cr?: ContextRecorder): Nullable<Keyword_4> {
        return this.regexAccept(String.raw`f[ií]or|br[eé]ag`, $$dpth + 1, cr);
    }
    public matchKeyword_5($$dpth: number, cr?: ContextRecorder): Nullable<Keyword_5> {
        return this.regexAccept(String.raw`gn[ií]omh`, $$dpth + 1, cr);
    }
    public matchKeyword_6($$dpth: number, cr?: ContextRecorder): Nullable<Keyword_6> {
        return this.regexAccept(String.raw`chun-cinn`, $$dpth + 1, cr);
    }
    public matchKeyword_7($$dpth: number, cr?: ContextRecorder): Nullable<Keyword_7> {
        return this.regexAccept(String.raw`neamhn[ií]`, $$dpth + 1, cr);
    }
    public matchKeyword_8($$dpth: number, cr?: ContextRecorder): Nullable<Keyword_8> {
        return this.regexAccept(String.raw`toradh`, $$dpth + 1, cr);
    }
    public matchKeyword_9($$dpth: number, cr?: ContextRecorder): Nullable<Keyword_9> {
        return this.regexAccept(String.raw`creatlach`, $$dpth + 1, cr);
    }
    public test(): boolean {
        const mrk = this.mark();
        const res = this.matchProgram(0);
        const ans = res !== null && this.finished();
        this.reset(mrk);
        return ans;
    }
    public parse(): ParseResult {
        const mrk = this.mark();
        const res = this.matchProgram(0);
        if (res && this.finished()) {
            return new ParseResult(res, null);
        }
        this.reset(mrk);
        const rec = new ErrorTracker();
        this.matchProgram(0, rec);
        return new ParseResult(res, rec.getErr());
    }
    private mark(): PosInfo {
        return this.pos;
    }
    private loop<T>(func: $$RuleType<T>, star: boolean = false): Nullable<T[]> {
        const mrk = this.mark();
        const res: T[] = [];
        for (;;) {
            const t = func();
            if (t === null) {
                break;
            }
            res.push(t);
        }
        if (star || res.length > 0) {
            return res;
        }
        this.reset(mrk);
        return null;
    }
    private runner<T>($$dpth: number, fn: $$RuleType<T>, cr?: ContextRecorder): $$RuleType<T> {
        return () => {
            const mrk = this.mark();
            const res = cr ? (() => {
                const extraInfo: string[] = [];
                const result = fn((msg: string) => extraInfo.push(msg));
                cr.record(mrk, $$dpth, result, this.negating, extraInfo);
                return result;
            })() : fn();
            if (res !== null) {
                return res;
            }
            this.reset(mrk);
            return null;
        };
    }
    private choice<T>(fns: Array<$$RuleType<T>>): Nullable<T> {
        for (const f of fns) {
            const res = f();
            if (res !== null) {
                return res;
            }
        }
        return null;
    }
    private regexAccept(match: string, dpth: number, cr?: ContextRecorder): Nullable<string> {
        return this.runner<string>(dpth,
            (log) => {
                if (log) {
                    if (this.negating) {
                        log("$$!StrMatch");
                    } else {
                        log("$$StrMatch");
                    }
                    log(match);
                }
                const reg = new RegExp(match, "y");
                reg.lastIndex = this.mark().overallPos;
                const res = reg.exec(this.input);
                if (res) {
                    let lineJmp = 0;
                    let lind = -1;
                    for (let i = 0; i < res[0].length; ++i) {
                        if (res[0][i] === "\n") {
                            ++lineJmp;
                            lind = i;
                        }
                    }
                    this.pos = {
                        overallPos: reg.lastIndex,
                        line: this.pos.line + lineJmp,
                        offset: lind === -1 ? this.pos.offset + res[0].length : (res[0].length - lind)
                    };
                    return res[0];
                }
                return null;
            }, cr)();
    }
    private noConsume<T>(fn: $$RuleType<T>): Nullable<T> {
        const mrk = this.mark();
        const res = fn();
        this.reset(mrk);
        return res;
    }
    private negate<T>(fn: $$RuleType<T>): Nullable<boolean> {
        const mrk = this.mark();
        const oneg = this.negating;
        this.negating = !oneg;
        const res = fn();
        this.negating = oneg;
        this.reset(mrk);
        return res === null ? true : null;
    }
}
export function parse(s: string): ParseResult {
    const p = new Parser(s);
    return p.parse();
}
export class ParseResult {
    public ast: Nullable<Program>;
    public err: Nullable<SyntaxErr>;
    constructor(ast: Nullable<Program>, err: Nullable<SyntaxErr>) {
        this.ast = ast;
        this.err = err;
    }
}
export interface PosInfo {
    readonly overallPos: number;
    readonly line: number;
    readonly offset: number;
}
export class SyntaxErr {
    public pos: PosInfo;
    public exprules: string[];
    public expmatches: string[];
    constructor(pos: PosInfo, exprules: Set<string>, expmatches: Set<string>) {
        this.pos = pos;
        this.exprules = [...exprules];
        this.expmatches = [...expmatches];
    }
    public toString(): string {
        return `Syntax Error at line ${this.pos.line}:${this.pos.offset}. Tried to match rules ${this.exprules.join(", ")}. Expected one of ${this.expmatches.map((x) => ` '${x}'`)}`;
    }
}
class ErrorTracker implements ContextRecorder {
    private mxpos: PosInfo = {overallPos: -1, line: -1, offset: -1};
    private mnd: number = -1;
    private prules: Set<string> = new Set();
    private pmatches: Set<string> = new Set();
    public record(pos: PosInfo, depth: number, result: any, negating: boolean, extraInfo: string[]) {
        if ((result === null) === negating) {
            return;
        }
        if (pos.overallPos > this.mxpos.overallPos) {
            this.mxpos = pos;
            this.mnd = depth;
            this.pmatches.clear();
            this.prules.clear();
        } else if (pos.overallPos === this.mxpos.overallPos && depth < this.mnd) {
            this.mnd = depth;
            this.prules.clear();
        }
        if (this.mxpos.overallPos === pos.overallPos && extraInfo.length >= 2) {
            if (extraInfo[0] === "$$StrMatch") {
                this.pmatches.add(extraInfo[1]);
            }
            if (extraInfo[0] === "$$!StrMatch") {
                this.pmatches.add(`not ${extraInfo[1]}`);
            }
        }
        if (this.mxpos.overallPos === pos.overallPos && this.mnd === depth) {
            extraInfo.forEach((x) => { if (x !== "$$StrMatch" && x !== "$$!StrMatch") { this.prules.add(x); } });
        }
    }
    public getErr(): SyntaxErr | null {
        if (this.mxpos.overallPos !== -1) {
            return new SyntaxErr(this.mxpos, this.prules, this.pmatches);
        }
        return null;
    }
}
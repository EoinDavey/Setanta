---
import { Environment } from "./env";
import { callFunc, idxList, Value } from "./values";
import { unescapeChars } from "./litreacha";
import * as Asserts from "./asserts";
import * as Checks from "./checks";
import { orBinOp, andBinOp, binOpEvalFn } from "./binops";
import { objLookupsEval, postfixArgsEval, csArgsEval, prefEval, EvalFn } from "./evals";
---
Program     := stmts=AsgnStmt* _
AsgnStmt    := IfStmt
             | BlockStmt
             | NuairStmt
             | LeStmt
             | CCStmt
             | BrisStmt
             | CtlchStmt
             | GniomhStmt
             | ToradhStmt
             | AssgnStmt
             | DefnStmt
             | Expr
NonAsgnStmt := IfStmt
             | NuairStmt
             | LeStmt
             | CCStmt
             | BrisStmt
             | ToradhStmt
             | BlockStmt
             | AssgnStmt
             | Expr
IfStmt      := _ 'm[áa]' &gap expr=Expr &gap stmt=NonAsgnStmt elsebranch={_ 'n[oó]' &gap stmt=NonAsgnStmt}?
BlockStmt   := _ '{' blk=AsgnStmt* _ '}'
NuairStmt   := _ 'nuair-a' expr=Expr &gap stmt=NonAsgnStmt
LeStmt      := _ 'le' &gap id=ID _ 'idir' _ '\('strt=Expr _ ',' end=Expr step={_ ',' step=Expr}? _ '\)' stmt=NonAsgnStmt
DefnStmt    := _ id=ID _ ':=' _ expr=Expr
AssgnStmt   := _ lhs=Postfix _ '=' _ expr=Expr
GniomhStmt  := _ 'gn[íi]omh' &gap id=ID _ '\(' args=CSIDs? _ '\)' _ '{'
    stmts=AsgnStmt*
_ '}'
CtlchStmt   := _ 'creatlach' &gap id=ID tuis={_ 'ó' id=ID}? _ '{'
    gniomhs=GniomhStmt*
_ '}'
BrisStmt    := _ 'bris'
CCStmt      := _ 'chun-cinn'
ToradhStmt  := _ 'toradh' &gap exp=Expr?
Expr        := And
And         := head=Or tail={_ '\&' trm=Or}*
               .evalfn = EvalFn { return andBinOp(this); }
Or          := head=Eq tail={_ '\|' trm=Eq}*
               .evalfn = EvalFn { return orBinOp(this) }
Eq          := head=Comp tail={_ op='[!=]=' trm=Comp}*
               .evalfn = EvalFn { return binOpEvalFn(this) }
Comp        := head=Sum tail={_ op=Compare trm=Sum}*
               .evalfn = EvalFn { return binOpEvalFn(this) }
Sum         := head=Product tail={_ op=PlusMinus trm=Product}*
               .evalfn = EvalFn { return binOpEvalFn(this) }
Product     := head=Prefix tail={_ op=MulDiv trm=Prefix}*
               .evalfn = EvalFn { return binOpEvalFn(this) }
Prefix      := _ op='-|!'? pf=Postfix
               .evalfn = EvalFn { return prefEval(this) }
Postfix     := at=ObjLookups ops=PostOp*
               .evalfn = EvalFn { return postfixArgsEval(this); }
ObjLookups  := _ attrs={id=ID '@' !wspace}* root=Atom
               .evalfn = EvalFn { return objLookupsEval(this); }
PostOp      := '\(' args=CSArgs? _ '\)' | '\[' expr=Expr '\]'
Atom        :=  _ '\(' trm=Expr '\)'
               .evalfn = EvalFn { return (env: Environment) => this.trm.evalfn(env); }
             | ID
             | Litreacha
             | Int
             | Bool
             | Neamhni
             | ListLit
LSpec       := id=ID ops=PostOp*
ListLit     := _ '\[' els=CSArgs? _ '\]'
               .evalfn = EvalFn {
                   return (env: Environment) => this.els ? this.els.evalfn(env) : Promise.resolve([]);
               }
CSArgs      := head=Expr tail={_ ',' exp=Expr}*
               .evalfn = (env:Environment)=>Promise<Value[]> { return csArgsEval(this); }
CSIDs       := head=ID tail={_ ',' id=ID}*
ID          := _ !{Keyword gap} id='[a-zA-Z_áéíóúÁÉÍÓÚ]+'
               .evalfn = EvalFn {
                   return (env: Environment) => Promise.resolve(env.get(this.id));
               }
Bool        := _ bool='f[ií]or|breag'
               .evalfn = EvalFn {
                   const x = this.bool === 'fior' || this.bool === 'fíor';
                   return () => Promise.resolve(x);
               }
Neamhni     := _ 'neamhn[ií]'
               .evalfn = EvalFn { return () => Promise.resolve(null); }
Int         := _ int='-?[0-9]+'
               .evalfn = EvalFn { 
                   const v = parseInt(this.int, 10);
                   return () => Promise.resolve(v);
               }
Litreacha   := _ '\'' val='([^\'\\]|\\.)*' '\''
               .evalfn = EvalFn {
                    const x = unescapeChars(this.val);
                    return () => Promise.resolve(x);
               }
_           := wspace*
wspace      := '(?:\s|>--(?:(?!--<).)*(--<|\n))'
gap         := { wspace | '[^a-zA-Z0-9áéíóúÁÉÍÓÚ]' }+ | '$'
PlusMinus   := '\+|-'
MulDiv      := '\*|\/|%'
Compare     := '<=|>=|<|>'
Keyword     := 'm[áa]' | 'n[oó]' | 'nuair-a' | 'f[ií]or|breag'
    | 'gn[ií]omh' | 'chun-cinn' | 'neamhn[ií]' | 'toradh' | 'creatlach'

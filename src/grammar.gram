---
import { Environment } from "./env";
import { callFunc, idxList, Value } from "./values";
import { unescapeChars } from "./litreacha";
import * as Asserts from "./asserts";
import * as Checks from "./checks";
import { orBinOp, orQuickBinOp, andBinOp, andQuickBinOp,
    binOpEvalFn, binOpQuickEvalFn } from "./binops";
import { objLookupsEval, postfixArgsEval, csArgsEval, prefEval, EvalFn } from "./evals";
import { MaybeQuickEv, qBoolEval, qCSArgsEval, qEvalToEval, qIdEval, qIntEval,
    qObjLookupsEval, qListLitEval, qLitreachaEval, qPostfixArgsEval, qPrefEval, 
    QuickEvalFn } from "./evals";
---
Program     := stmts=AsgnStmt* _
AsgnStmt    := IfStmt
             | BlockStmt
             | NuairStmt
             | LeStmt
             | CCStmt
             | BrisStmt
             | CtlchStmt
             | GniomhStmt
             | ToradhStmt
             | AssgnStmt
             | DefnStmt
             | Expr
NonAsgnStmt := IfStmt
             | NuairStmt
             | LeStmt
             | CCStmt
             | BrisStmt
             | ToradhStmt
             | BlockStmt
             | AssgnStmt
             | Expr
IfStmt      := _ 'm[áa]' &gap expr=Expr &gap stmt=NonAsgnStmt elsebranch={_ 'n[oó]' &gap stmt=NonAsgnStmt}?
BlockStmt   := _ '{' blk=AsgnStmt* _ '}'
NuairStmt   := _ 'nuair-a' expr=Expr &gap stmt=NonAsgnStmt
LeStmt      := _ 'le' &gap id=ID _ 'idir' _ '\('strt=Expr _ ',' end=Expr step={_ ',' step=Expr}? _ '\)' stmt=NonAsgnStmt
DefnStmt    := _ id=ID _ ':=' _ expr=Expr
AssgnStmt   := _ lhs=Postfix _ op=AsgnOp _ expr=Expr
GniomhStmt  := _ 'gn[íi]omh' &gap id=ID _ '\(' args=CSIDs? _ '\)' _ '{'
    stmts=AsgnStmt*
_ '}'
CtlchStmt   := _ 'creatlach' &gap id=ID tuis={_ 'ó' id=ID}? _ '{'
    gniomhs=GniomhStmt*
_ '}'
BrisStmt    := _ 'bris'
CCStmt      := _ 'chun-cinn'
ToradhStmt  := _ 'toradh' &gap exp=Expr?
Expr        := And
And         := head=Or tail={_ '\&' trm=Or}*
               .evalfn = EvalFn { return andBinOp(this); }
               .qeval = MaybeQuickEv { return andQuickBinOp(this); }
Or          := head=Eq tail={_ '\|' trm=Eq}*
               .evalfn = EvalFn { return orBinOp(this) }
               .qeval = MaybeQuickEv { return orQuickBinOp(this); }
Eq          := head=Comp tail={_ op='[!=]=' trm=Comp}*
               .evalfn = EvalFn { return binOpEvalFn(this) }
               .qeval = MaybeQuickEv { return binOpQuickEvalFn(this); }
Comp        := head=Sum tail={_ op=Compare trm=Sum}*
               .evalfn = EvalFn { return binOpEvalFn(this) }
               .qeval = MaybeQuickEv { return binOpQuickEvalFn(this); }
Sum         := head=Product tail={_ op=PlusMinus trm=Product}*
               .evalfn = EvalFn { return binOpEvalFn(this) }
               .qeval = MaybeQuickEv { return binOpQuickEvalFn(this); }
Product     := head=Prefix tail={_ op=MulDiv trm=Prefix}*
               .evalfn = EvalFn { return binOpEvalFn(this); }
               .qeval = MaybeQuickEv { return binOpQuickEvalFn(this); }
Prefix      := _ op='-|!'? pf=Postfix
               .evalfn = EvalFn { return prefEval(this); }
               .qeval = MaybeQuickEv { return qPrefEval(this); }
Postfix     := at=ObjLookups ops=PostOp*
               .evalfn = EvalFn { return postfixArgsEval(this); }
               .qeval = MaybeQuickEv { return qPostfixArgsEval(this); }
ObjLookups  := _ attrs={id=ID '@' !wspace}* root=Atom
               .evalfn = EvalFn { return objLookupsEval(this); }
               .qeval = MaybeQuickEv { return qObjLookupsEval(this); }
PostOp      := '\(' args=CSArgs? _ '\)' | '\[' expr=Expr '\]'
Atom        :=  _ '\(' trm=Expr '\)'
               .evalfn = EvalFn { return (env: Environment) => this.trm.evalfn(env); }
               .qeval = MaybeQuickEv {
                    const childF = this.trm.qeval;
                    return childF === null ? null : childF.bind(this.trm);
               }
             | ID
             | Litreacha
             | Int
             | Bool
             | Neamhni
             | ListLit
LSpec       := id=ID ops=PostOp*
ListLit     := _ '\[' els=CSArgs? _ '\]'
               .evalfn = EvalFn {
                   return (env: Environment) => this.els ? this.els.evalfn(env) : Promise.resolve([]);
               }
               .qeval = MaybeQuickEv { return qListLitEval(this); }
CSArgs      := head=Expr tail={_ ',' exp=Expr}*
               .evalfn = (env:Environment)=>Promise<Value[]> { return csArgsEval(this); }
               .qeval = MaybeQuickEv { return qCSArgsEval(this); }
CSIDs       := head=ID tail={_ ',' id=ID}*
ID          := _ !{Keyword gap} id='[a-zA-Z_áéíóúÁÉÍÓÚ]+'
               .evalfn = EvalFn { return qEvalToEval(qIdEval(this.id)); }
               .qeval = QuickEvalFn { return qIdEval(this.id); }
Bool        := _ bool='f[ií]or|br[eé]ag'
               .evalfn = EvalFn { return qEvalToEval(qBoolEval(this.bool)); }
               .qeval = QuickEvalFn { return qBoolEval(this.bool); }
Neamhni     := _ 'neamhn[ií]'
               .evalfn = EvalFn { return () => Promise.resolve(null); }
               .qeval = QuickEvalFn { return () => null; }
Int         := _ int='-?[0-9]+(?:\.[0-9]+)?'
               .evalfn = EvalFn { return qEvalToEval(qIntEval(this.int)); }
               .qeval = QuickEvalFn { return qIntEval(this.int); }
Litreacha   := _ '\'' val='([^\'\\]|\\.)*' '\''
               .evalfn = EvalFn { return qEvalToEval(qLitreachaEval(this.val)); }
               .qeval = QuickEvalFn { return qLitreachaEval(this.val); }
_           := wspace*
wspace      := '(?:\s|>--(?:(?!--<).)*(--<|\n|$))'
gap         := { wspace | '[^a-zA-Z0-9áéíóúÁÉÍÓÚ]' }+ | '$'
PlusMinus   := '\+|-'
AsgnOp      := '=|\+=|\*=|-=|%=|\/='
MulDiv      := '\*|\/\/|%|\/'
Compare     := '<=|>=|<|>'
Keyword     := 'm[áa]' | 'n[oó]' | 'nuair-a' | 'f[ií]or|br[eé]ag'
    | 'gn[ií]omh' | 'chun-cinn' | 'neamhn[ií]' | 'toradh' | 'creatlach'

/* AutoGenerated Code, changes may be overwritten
* INPUT GRAMMAR:
* Program     := AsgnStmt*
* AsgnStmt    := IfStmt
*              | BlockStmt
*              | NuairStmt
*              | AssgnStmt
*              | DefnStmt
*              | Expr
* NonAsgnStmt := IfStmt | NuairStmt | BlockStmt | AssgnStmt | Expr
* IfStmt      := _ 'm[áa]' _ expr=Expr _ stmt=NonAsgnStmt elsebranch={ _ 'n[oó]' _  stmt=NonAsgnStmt}?
* BlockStmt   := _ '{' blk=AsgnStmt* '}'
* NuairStmt   := _ 'nuair a' expr=Expr stmt=NonAsgnStmt
* DefnStmt    := _ id=ID _ ':=' _ expr=Expr
* AssgnStmt   := _ id=ID _ '=' _ expr=Expr
* Expr        := And
* And         := head=Or tail={'\&' trm=Or}*
* Or          := head=Eq tail={'\|' trm=Eq}*
* Eq          := head=Comp tail={op='[!=]=' trm=Comp}*
* Comp        := head=Sum tail={op=Compare trm=Sum}*
* Sum         := head=Product tail={op=PlusMinus trm=Product}*
* Product     := head=Atom tail={op=MulDiv trm=Atom}*
* Atom        := _ trm=INT _ | _ trm=ID _ | _ '\(' trm=Expr '\)' _
* PlusMinus   := '\+|-'
* MulDiv      := '\*|\/|%'
* Compare     := '(<=)|(>=)|<|>'
* Keyword     := 'm[áa]' | 'n[oó]' | 'nuair a'
* ID          := !Keyword id='[a-zA-Z_áéíóúÁÉÍÓÚ]+'
* INT         := '[0-9]+'
* _           := '\s*'
*/
type Nullable<T> = T | null;
type $$RuleType<T> = (log? : (msg : string) => void) => Nullable<T>;
export interface ContextRecorder {
    record(pos: PosInfo, depth : number, result: any, negating : boolean, extraInfo : string[]) : void;
}
interface ASTNodeIntf {
    kind: ASTKinds;
}
export enum ASTKinds {
    Program,
    AsgnStmt_1,
    AsgnStmt_2,
    AsgnStmt_3,
    AsgnStmt_4,
    AsgnStmt_5,
    AsgnStmt_6,
    NonAsgnStmt_1,
    NonAsgnStmt_2,
    NonAsgnStmt_3,
    NonAsgnStmt_4,
    NonAsgnStmt_5,
    IfStmt,
    IfStmt_$0,
    BlockStmt,
    NuairStmt,
    DefnStmt,
    AssgnStmt,
    Expr,
    And,
    And_$0,
    Or,
    Or_$0,
    Eq,
    Eq_$0,
    Comp,
    Comp_$0,
    Sum,
    Sum_$0,
    Product,
    Product_$0,
    Atom_1,
    Atom_2,
    Atom_3,
    PlusMinus,
    MulDiv,
    Compare,
    Keyword_1,
    Keyword_2,
    Keyword_3,
    ID,
    INT,
    _,
}
export type Program = AsgnStmt[];
export type AsgnStmt = AsgnStmt_1 | AsgnStmt_2 | AsgnStmt_3 | AsgnStmt_4 | AsgnStmt_5 | AsgnStmt_6;
export type AsgnStmt_1 = IfStmt;
export type AsgnStmt_2 = BlockStmt;
export type AsgnStmt_3 = NuairStmt;
export type AsgnStmt_4 = AssgnStmt;
export type AsgnStmt_5 = DefnStmt;
export type AsgnStmt_6 = Expr;
export type NonAsgnStmt = NonAsgnStmt_1 | NonAsgnStmt_2 | NonAsgnStmt_3 | NonAsgnStmt_4 | NonAsgnStmt_5;
export type NonAsgnStmt_1 = IfStmt;
export type NonAsgnStmt_2 = NuairStmt;
export type NonAsgnStmt_3 = BlockStmt;
export type NonAsgnStmt_4 = AssgnStmt;
export type NonAsgnStmt_5 = Expr;
export interface IfStmt {
    kind : ASTKinds.IfStmt;
    expr : Expr;
    stmt : NonAsgnStmt;
    elsebranch : Nullable<IfStmt_$0>;
}
export interface IfStmt_$0 {
    kind : ASTKinds.IfStmt_$0;
    stmt : NonAsgnStmt;
}
export interface BlockStmt {
    kind : ASTKinds.BlockStmt;
    blk : AsgnStmt[];
}
export interface NuairStmt {
    kind : ASTKinds.NuairStmt;
    expr : Expr;
    stmt : NonAsgnStmt;
}
export interface DefnStmt {
    kind : ASTKinds.DefnStmt;
    id : ID;
    expr : Expr;
}
export interface AssgnStmt {
    kind : ASTKinds.AssgnStmt;
    id : ID;
    expr : Expr;
}
export type Expr = And;
export interface And {
    kind : ASTKinds.And;
    head : Or;
    tail : And_$0[];
}
export interface And_$0 {
    kind : ASTKinds.And_$0;
    trm : Or;
}
export interface Or {
    kind : ASTKinds.Or;
    head : Eq;
    tail : Or_$0[];
}
export interface Or_$0 {
    kind : ASTKinds.Or_$0;
    trm : Eq;
}
export interface Eq {
    kind : ASTKinds.Eq;
    head : Comp;
    tail : Eq_$0[];
}
export interface Eq_$0 {
    kind : ASTKinds.Eq_$0;
    op : string;
    trm : Comp;
}
export interface Comp {
    kind : ASTKinds.Comp;
    head : Sum;
    tail : Comp_$0[];
}
export interface Comp_$0 {
    kind : ASTKinds.Comp_$0;
    op : Compare;
    trm : Sum;
}
export interface Sum {
    kind : ASTKinds.Sum;
    head : Product;
    tail : Sum_$0[];
}
export interface Sum_$0 {
    kind : ASTKinds.Sum_$0;
    op : PlusMinus;
    trm : Product;
}
export interface Product {
    kind : ASTKinds.Product;
    head : Atom;
    tail : Product_$0[];
}
export interface Product_$0 {
    kind : ASTKinds.Product_$0;
    op : MulDiv;
    trm : Atom;
}
export type Atom = Atom_1 | Atom_2 | Atom_3;
export interface Atom_1 {
    kind : ASTKinds.Atom_1;
    trm : INT;
}
export interface Atom_2 {
    kind : ASTKinds.Atom_2;
    trm : ID;
}
export interface Atom_3 {
    kind : ASTKinds.Atom_3;
    trm : Expr;
}
export type PlusMinus = string;
export type MulDiv = string;
export type Compare = string;
export type Keyword = Keyword_1 | Keyword_2 | Keyword_3;
export type Keyword_1 = string;
export type Keyword_2 = string;
export type Keyword_3 = string;
export interface ID {
    kind : ASTKinds.ID;
    id : string;
}
export type INT = string;
export type _ = string;
export class Parser {
    private pos : PosInfo;
    readonly input : string;
    private negating: boolean = false;
    constructor(input : string) {
        this.pos = new PosInfo(0, 1, 0);
        this.input = input;
    }
    private mark() : PosInfo {
        return this.pos;
    }
    reset(pos : PosInfo) {
        this.pos = pos;
    }
    finished() : boolean {
        return this.pos.overall_pos === this.input.length;
    }
    private loop<T>(func : $$RuleType<T>, star : boolean = false) : Nullable<T[]> {
        const mrk = this.mark();
        let res : T[] = [];
        for(;;) {
            const t = func();
            if(!t)
                break;
            res.push(t);
        }
        if(star || res.length > 0)
            return res;
        this.reset(mrk);
        return null;
    }
    private runner<T>($$dpth : number, fn : $$RuleType<T>,
        cr? : ContextRecorder) : $$RuleType<T> {
        return () => {
            const mrk = this.mark();
            const res = cr ? (()=>{
                let extraInfo : string[] = [];
                const res = fn((msg : string) => extraInfo.push(msg));
                cr.record(mrk, $$dpth, res, this.negating, extraInfo);
                return res;
            })() : fn();
            if(res !== null)
                return res;
            this.reset(mrk);
            return null
        }
    }
    private choice<T>(fns : $$RuleType<T>[]) : Nullable<T> {
        for(let f of fns){
            const res = f();
            if(res)
                return res;
        }
        return null;
    }
    private regexAccept(match : string, dpth : number, cr? : ContextRecorder) : Nullable<string> {
        return this.runner<string>(dpth,
            (log) => {
                if(log){
                    if(this.negating)
                        log('$$!StrMatch');
                    else
                        log('$$StrMatch');
                    log(match);
                }
                var reg = new RegExp(match, 'y');
                reg.lastIndex = this.mark().overall_pos;
                const res = reg.exec(this.input);
                if(res){
                    let lineJmp = 0;
                    let lind = -1;
                    for(let i = 0; i < res[0].length; ++i){
                        if(res[0][i] === '\n'){
                            ++lineJmp;
                            lind = i;
                        }
                    }
                    this.pos = new PosInfo(reg.lastIndex, this.pos.line + lineJmp, lind === -1 ? this.pos.offset + res[0].length: (res[0].length - lind));
                    return res[0];
                }
                return null;
            }, cr)();
    }
    private noConsume<T>(fn : $$RuleType<T>) : Nullable<T> {
        const mrk = this.mark();
        const res = fn();
        this.reset(mrk);
        return res;
    }
    private negate<T>(fn : $$RuleType<T>) : Nullable<boolean> {
        const mrk = this.mark();
        const oneg = this.negating;
        this.negating = !oneg
        const res = fn();
        this.negating = oneg;
        this.reset(mrk);
        return res === null ? true : null;
    }
    matchProgram($$dpth : number, cr? : ContextRecorder) : Nullable<Program> {
        return this.loop<AsgnStmt>(()=> this.matchAsgnStmt($$dpth + 1, cr), true);
    }
    matchAsgnStmt($$dpth : number, cr? : ContextRecorder) : Nullable<AsgnStmt> {
        return this.choice<AsgnStmt>([
            () => { return this.matchAsgnStmt_1($$dpth + 1, cr) },
            () => { return this.matchAsgnStmt_2($$dpth + 1, cr) },
            () => { return this.matchAsgnStmt_3($$dpth + 1, cr) },
            () => { return this.matchAsgnStmt_4($$dpth + 1, cr) },
            () => { return this.matchAsgnStmt_5($$dpth + 1, cr) },
            () => { return this.matchAsgnStmt_6($$dpth + 1, cr) },
        ]);
    }
    matchAsgnStmt_1($$dpth : number, cr? : ContextRecorder) : Nullable<AsgnStmt_1> {
        return this.matchIfStmt($$dpth + 1, cr);
    }
    matchAsgnStmt_2($$dpth : number, cr? : ContextRecorder) : Nullable<AsgnStmt_2> {
        return this.matchBlockStmt($$dpth + 1, cr);
    }
    matchAsgnStmt_3($$dpth : number, cr? : ContextRecorder) : Nullable<AsgnStmt_3> {
        return this.matchNuairStmt($$dpth + 1, cr);
    }
    matchAsgnStmt_4($$dpth : number, cr? : ContextRecorder) : Nullable<AsgnStmt_4> {
        return this.matchAssgnStmt($$dpth + 1, cr);
    }
    matchAsgnStmt_5($$dpth : number, cr? : ContextRecorder) : Nullable<AsgnStmt_5> {
        return this.matchDefnStmt($$dpth + 1, cr);
    }
    matchAsgnStmt_6($$dpth : number, cr? : ContextRecorder) : Nullable<AsgnStmt_6> {
        return this.matchExpr($$dpth + 1, cr);
    }
    matchNonAsgnStmt($$dpth : number, cr? : ContextRecorder) : Nullable<NonAsgnStmt> {
        return this.choice<NonAsgnStmt>([
            () => { return this.matchNonAsgnStmt_1($$dpth + 1, cr) },
            () => { return this.matchNonAsgnStmt_2($$dpth + 1, cr) },
            () => { return this.matchNonAsgnStmt_3($$dpth + 1, cr) },
            () => { return this.matchNonAsgnStmt_4($$dpth + 1, cr) },
            () => { return this.matchNonAsgnStmt_5($$dpth + 1, cr) },
        ]);
    }
    matchNonAsgnStmt_1($$dpth : number, cr? : ContextRecorder) : Nullable<NonAsgnStmt_1> {
        return this.matchIfStmt($$dpth + 1, cr);
    }
    matchNonAsgnStmt_2($$dpth : number, cr? : ContextRecorder) : Nullable<NonAsgnStmt_2> {
        return this.matchNuairStmt($$dpth + 1, cr);
    }
    matchNonAsgnStmt_3($$dpth : number, cr? : ContextRecorder) : Nullable<NonAsgnStmt_3> {
        return this.matchBlockStmt($$dpth + 1, cr);
    }
    matchNonAsgnStmt_4($$dpth : number, cr? : ContextRecorder) : Nullable<NonAsgnStmt_4> {
        return this.matchAssgnStmt($$dpth + 1, cr);
    }
    matchNonAsgnStmt_5($$dpth : number, cr? : ContextRecorder) : Nullable<NonAsgnStmt_5> {
        return this.matchExpr($$dpth + 1, cr);
    }
    matchIfStmt($$dpth : number, cr? : ContextRecorder) : Nullable<IfStmt> {
        return this.runner<IfStmt>($$dpth,
            (log) => {
                if(log)
                    log('IfStmt');
                let expr : Nullable<Expr>;
                let stmt : Nullable<NonAsgnStmt>;
                let elsebranch : Nullable<Nullable<IfStmt_$0>>;
                let res : Nullable<IfStmt> = null;
                if(true
                    && this.match_($$dpth + 1, cr) != null
                    && this.regexAccept(String.raw`m[áa]`, $$dpth+1, cr) != null
                    && this.match_($$dpth + 1, cr) != null
                    && (expr = this.matchExpr($$dpth + 1, cr)) != null
                    && this.match_($$dpth + 1, cr) != null
                    && (stmt = this.matchNonAsgnStmt($$dpth + 1, cr)) != null
                    && ((elsebranch = this.matchIfStmt_$0($$dpth + 1, cr)) || true)
                )
                    res = {kind: ASTKinds.IfStmt, expr : expr, stmt : stmt, elsebranch : elsebranch};
                return res;
            }, cr)();
    }
    matchIfStmt_$0($$dpth : number, cr? : ContextRecorder) : Nullable<IfStmt_$0> {
        return this.runner<IfStmt_$0>($$dpth,
            (log) => {
                if(log)
                    log('IfStmt_$0');
                let stmt : Nullable<NonAsgnStmt>;
                let res : Nullable<IfStmt_$0> = null;
                if(true
                    && this.match_($$dpth + 1, cr) != null
                    && this.regexAccept(String.raw`n[oó]`, $$dpth+1, cr) != null
                    && this.match_($$dpth + 1, cr) != null
                    && (stmt = this.matchNonAsgnStmt($$dpth + 1, cr)) != null
                )
                    res = {kind: ASTKinds.IfStmt_$0, stmt : stmt};
                return res;
            }, cr)();
    }
    matchBlockStmt($$dpth : number, cr? : ContextRecorder) : Nullable<BlockStmt> {
        return this.runner<BlockStmt>($$dpth,
            (log) => {
                if(log)
                    log('BlockStmt');
                let blk : Nullable<AsgnStmt[]>;
                let res : Nullable<BlockStmt> = null;
                if(true
                    && this.match_($$dpth + 1, cr) != null
                    && this.regexAccept(String.raw`{`, $$dpth+1, cr) != null
                    && (blk = this.loop<AsgnStmt>(()=> this.matchAsgnStmt($$dpth + 1, cr), true)) != null
                    && this.regexAccept(String.raw`}`, $$dpth+1, cr) != null
                )
                    res = {kind: ASTKinds.BlockStmt, blk : blk};
                return res;
            }, cr)();
    }
    matchNuairStmt($$dpth : number, cr? : ContextRecorder) : Nullable<NuairStmt> {
        return this.runner<NuairStmt>($$dpth,
            (log) => {
                if(log)
                    log('NuairStmt');
                let expr : Nullable<Expr>;
                let stmt : Nullable<NonAsgnStmt>;
                let res : Nullable<NuairStmt> = null;
                if(true
                    && this.match_($$dpth + 1, cr) != null
                    && this.regexAccept(String.raw`nuair a`, $$dpth+1, cr) != null
                    && (expr = this.matchExpr($$dpth + 1, cr)) != null
                    && (stmt = this.matchNonAsgnStmt($$dpth + 1, cr)) != null
                )
                    res = {kind: ASTKinds.NuairStmt, expr : expr, stmt : stmt};
                return res;
            }, cr)();
    }
    matchDefnStmt($$dpth : number, cr? : ContextRecorder) : Nullable<DefnStmt> {
        return this.runner<DefnStmt>($$dpth,
            (log) => {
                if(log)
                    log('DefnStmt');
                let id : Nullable<ID>;
                let expr : Nullable<Expr>;
                let res : Nullable<DefnStmt> = null;
                if(true
                    && this.match_($$dpth + 1, cr) != null
                    && (id = this.matchID($$dpth + 1, cr)) != null
                    && this.match_($$dpth + 1, cr) != null
                    && this.regexAccept(String.raw`:=`, $$dpth+1, cr) != null
                    && this.match_($$dpth + 1, cr) != null
                    && (expr = this.matchExpr($$dpth + 1, cr)) != null
                )
                    res = {kind: ASTKinds.DefnStmt, id : id, expr : expr};
                return res;
            }, cr)();
    }
    matchAssgnStmt($$dpth : number, cr? : ContextRecorder) : Nullable<AssgnStmt> {
        return this.runner<AssgnStmt>($$dpth,
            (log) => {
                if(log)
                    log('AssgnStmt');
                let id : Nullable<ID>;
                let expr : Nullable<Expr>;
                let res : Nullable<AssgnStmt> = null;
                if(true
                    && this.match_($$dpth + 1, cr) != null
                    && (id = this.matchID($$dpth + 1, cr)) != null
                    && this.match_($$dpth + 1, cr) != null
                    && this.regexAccept(String.raw`=`, $$dpth+1, cr) != null
                    && this.match_($$dpth + 1, cr) != null
                    && (expr = this.matchExpr($$dpth + 1, cr)) != null
                )
                    res = {kind: ASTKinds.AssgnStmt, id : id, expr : expr};
                return res;
            }, cr)();
    }
    matchExpr($$dpth : number, cr? : ContextRecorder) : Nullable<Expr> {
        return this.matchAnd($$dpth + 1, cr);
    }
    matchAnd($$dpth : number, cr? : ContextRecorder) : Nullable<And> {
        return this.runner<And>($$dpth,
            (log) => {
                if(log)
                    log('And');
                let head : Nullable<Or>;
                let tail : Nullable<And_$0[]>;
                let res : Nullable<And> = null;
                if(true
                    && (head = this.matchOr($$dpth + 1, cr)) != null
                    && (tail = this.loop<And_$0>(()=> this.matchAnd_$0($$dpth + 1, cr), true)) != null
                )
                    res = {kind: ASTKinds.And, head : head, tail : tail};
                return res;
            }, cr)();
    }
    matchAnd_$0($$dpth : number, cr? : ContextRecorder) : Nullable<And_$0> {
        return this.runner<And_$0>($$dpth,
            (log) => {
                if(log)
                    log('And_$0');
                let trm : Nullable<Or>;
                let res : Nullable<And_$0> = null;
                if(true
                    && this.regexAccept(String.raw`\&`, $$dpth+1, cr) != null
                    && (trm = this.matchOr($$dpth + 1, cr)) != null
                )
                    res = {kind: ASTKinds.And_$0, trm : trm};
                return res;
            }, cr)();
    }
    matchOr($$dpth : number, cr? : ContextRecorder) : Nullable<Or> {
        return this.runner<Or>($$dpth,
            (log) => {
                if(log)
                    log('Or');
                let head : Nullable<Eq>;
                let tail : Nullable<Or_$0[]>;
                let res : Nullable<Or> = null;
                if(true
                    && (head = this.matchEq($$dpth + 1, cr)) != null
                    && (tail = this.loop<Or_$0>(()=> this.matchOr_$0($$dpth + 1, cr), true)) != null
                )
                    res = {kind: ASTKinds.Or, head : head, tail : tail};
                return res;
            }, cr)();
    }
    matchOr_$0($$dpth : number, cr? : ContextRecorder) : Nullable<Or_$0> {
        return this.runner<Or_$0>($$dpth,
            (log) => {
                if(log)
                    log('Or_$0');
                let trm : Nullable<Eq>;
                let res : Nullable<Or_$0> = null;
                if(true
                    && this.regexAccept(String.raw`\|`, $$dpth+1, cr) != null
                    && (trm = this.matchEq($$dpth + 1, cr)) != null
                )
                    res = {kind: ASTKinds.Or_$0, trm : trm};
                return res;
            }, cr)();
    }
    matchEq($$dpth : number, cr? : ContextRecorder) : Nullable<Eq> {
        return this.runner<Eq>($$dpth,
            (log) => {
                if(log)
                    log('Eq');
                let head : Nullable<Comp>;
                let tail : Nullable<Eq_$0[]>;
                let res : Nullable<Eq> = null;
                if(true
                    && (head = this.matchComp($$dpth + 1, cr)) != null
                    && (tail = this.loop<Eq_$0>(()=> this.matchEq_$0($$dpth + 1, cr), true)) != null
                )
                    res = {kind: ASTKinds.Eq, head : head, tail : tail};
                return res;
            }, cr)();
    }
    matchEq_$0($$dpth : number, cr? : ContextRecorder) : Nullable<Eq_$0> {
        return this.runner<Eq_$0>($$dpth,
            (log) => {
                if(log)
                    log('Eq_$0');
                let op : Nullable<string>;
                let trm : Nullable<Comp>;
                let res : Nullable<Eq_$0> = null;
                if(true
                    && (op = this.regexAccept(String.raw`[!=]=`, $$dpth+1, cr)) != null
                    && (trm = this.matchComp($$dpth + 1, cr)) != null
                )
                    res = {kind: ASTKinds.Eq_$0, op : op, trm : trm};
                return res;
            }, cr)();
    }
    matchComp($$dpth : number, cr? : ContextRecorder) : Nullable<Comp> {
        return this.runner<Comp>($$dpth,
            (log) => {
                if(log)
                    log('Comp');
                let head : Nullable<Sum>;
                let tail : Nullable<Comp_$0[]>;
                let res : Nullable<Comp> = null;
                if(true
                    && (head = this.matchSum($$dpth + 1, cr)) != null
                    && (tail = this.loop<Comp_$0>(()=> this.matchComp_$0($$dpth + 1, cr), true)) != null
                )
                    res = {kind: ASTKinds.Comp, head : head, tail : tail};
                return res;
            }, cr)();
    }
    matchComp_$0($$dpth : number, cr? : ContextRecorder) : Nullable<Comp_$0> {
        return this.runner<Comp_$0>($$dpth,
            (log) => {
                if(log)
                    log('Comp_$0');
                let op : Nullable<Compare>;
                let trm : Nullable<Sum>;
                let res : Nullable<Comp_$0> = null;
                if(true
                    && (op = this.matchCompare($$dpth + 1, cr)) != null
                    && (trm = this.matchSum($$dpth + 1, cr)) != null
                )
                    res = {kind: ASTKinds.Comp_$0, op : op, trm : trm};
                return res;
            }, cr)();
    }
    matchSum($$dpth : number, cr? : ContextRecorder) : Nullable<Sum> {
        return this.runner<Sum>($$dpth,
            (log) => {
                if(log)
                    log('Sum');
                let head : Nullable<Product>;
                let tail : Nullable<Sum_$0[]>;
                let res : Nullable<Sum> = null;
                if(true
                    && (head = this.matchProduct($$dpth + 1, cr)) != null
                    && (tail = this.loop<Sum_$0>(()=> this.matchSum_$0($$dpth + 1, cr), true)) != null
                )
                    res = {kind: ASTKinds.Sum, head : head, tail : tail};
                return res;
            }, cr)();
    }
    matchSum_$0($$dpth : number, cr? : ContextRecorder) : Nullable<Sum_$0> {
        return this.runner<Sum_$0>($$dpth,
            (log) => {
                if(log)
                    log('Sum_$0');
                let op : Nullable<PlusMinus>;
                let trm : Nullable<Product>;
                let res : Nullable<Sum_$0> = null;
                if(true
                    && (op = this.matchPlusMinus($$dpth + 1, cr)) != null
                    && (trm = this.matchProduct($$dpth + 1, cr)) != null
                )
                    res = {kind: ASTKinds.Sum_$0, op : op, trm : trm};
                return res;
            }, cr)();
    }
    matchProduct($$dpth : number, cr? : ContextRecorder) : Nullable<Product> {
        return this.runner<Product>($$dpth,
            (log) => {
                if(log)
                    log('Product');
                let head : Nullable<Atom>;
                let tail : Nullable<Product_$0[]>;
                let res : Nullable<Product> = null;
                if(true
                    && (head = this.matchAtom($$dpth + 1, cr)) != null
                    && (tail = this.loop<Product_$0>(()=> this.matchProduct_$0($$dpth + 1, cr), true)) != null
                )
                    res = {kind: ASTKinds.Product, head : head, tail : tail};
                return res;
            }, cr)();
    }
    matchProduct_$0($$dpth : number, cr? : ContextRecorder) : Nullable<Product_$0> {
        return this.runner<Product_$0>($$dpth,
            (log) => {
                if(log)
                    log('Product_$0');
                let op : Nullable<MulDiv>;
                let trm : Nullable<Atom>;
                let res : Nullable<Product_$0> = null;
                if(true
                    && (op = this.matchMulDiv($$dpth + 1, cr)) != null
                    && (trm = this.matchAtom($$dpth + 1, cr)) != null
                )
                    res = {kind: ASTKinds.Product_$0, op : op, trm : trm};
                return res;
            }, cr)();
    }
    matchAtom($$dpth : number, cr? : ContextRecorder) : Nullable<Atom> {
        return this.choice<Atom>([
            () => { return this.matchAtom_1($$dpth + 1, cr) },
            () => { return this.matchAtom_2($$dpth + 1, cr) },
            () => { return this.matchAtom_3($$dpth + 1, cr) },
        ]);
    }
    matchAtom_1($$dpth : number, cr? : ContextRecorder) : Nullable<Atom_1> {
        return this.runner<Atom_1>($$dpth,
            (log) => {
                if(log)
                    log('Atom_1');
                let trm : Nullable<INT>;
                let res : Nullable<Atom_1> = null;
                if(true
                    && this.match_($$dpth + 1, cr) != null
                    && (trm = this.matchINT($$dpth + 1, cr)) != null
                    && this.match_($$dpth + 1, cr) != null
                )
                    res = {kind: ASTKinds.Atom_1, trm : trm};
                return res;
            }, cr)();
    }
    matchAtom_2($$dpth : number, cr? : ContextRecorder) : Nullable<Atom_2> {
        return this.runner<Atom_2>($$dpth,
            (log) => {
                if(log)
                    log('Atom_2');
                let trm : Nullable<ID>;
                let res : Nullable<Atom_2> = null;
                if(true
                    && this.match_($$dpth + 1, cr) != null
                    && (trm = this.matchID($$dpth + 1, cr)) != null
                    && this.match_($$dpth + 1, cr) != null
                )
                    res = {kind: ASTKinds.Atom_2, trm : trm};
                return res;
            }, cr)();
    }
    matchAtom_3($$dpth : number, cr? : ContextRecorder) : Nullable<Atom_3> {
        return this.runner<Atom_3>($$dpth,
            (log) => {
                if(log)
                    log('Atom_3');
                let trm : Nullable<Expr>;
                let res : Nullable<Atom_3> = null;
                if(true
                    && this.match_($$dpth + 1, cr) != null
                    && this.regexAccept(String.raw`\(`, $$dpth+1, cr) != null
                    && (trm = this.matchExpr($$dpth + 1, cr)) != null
                    && this.regexAccept(String.raw`\)`, $$dpth+1, cr) != null
                    && this.match_($$dpth + 1, cr) != null
                )
                    res = {kind: ASTKinds.Atom_3, trm : trm};
                return res;
            }, cr)();
    }
    matchPlusMinus($$dpth : number, cr? : ContextRecorder) : Nullable<PlusMinus> {
        return this.regexAccept(String.raw`\+|-`, $$dpth+1, cr);
    }
    matchMulDiv($$dpth : number, cr? : ContextRecorder) : Nullable<MulDiv> {
        return this.regexAccept(String.raw`\*|\/|%`, $$dpth+1, cr);
    }
    matchCompare($$dpth : number, cr? : ContextRecorder) : Nullable<Compare> {
        return this.regexAccept(String.raw`(<=)|(>=)|<|>`, $$dpth+1, cr);
    }
    matchKeyword($$dpth : number, cr? : ContextRecorder) : Nullable<Keyword> {
        return this.choice<Keyword>([
            () => { return this.matchKeyword_1($$dpth + 1, cr) },
            () => { return this.matchKeyword_2($$dpth + 1, cr) },
            () => { return this.matchKeyword_3($$dpth + 1, cr) },
        ]);
    }
    matchKeyword_1($$dpth : number, cr? : ContextRecorder) : Nullable<Keyword_1> {
        return this.regexAccept(String.raw`m[áa]`, $$dpth+1, cr);
    }
    matchKeyword_2($$dpth : number, cr? : ContextRecorder) : Nullable<Keyword_2> {
        return this.regexAccept(String.raw`n[oó]`, $$dpth+1, cr);
    }
    matchKeyword_3($$dpth : number, cr? : ContextRecorder) : Nullable<Keyword_3> {
        return this.regexAccept(String.raw`nuair a`, $$dpth+1, cr);
    }
    matchID($$dpth : number, cr? : ContextRecorder) : Nullable<ID> {
        return this.runner<ID>($$dpth,
            (log) => {
                if(log)
                    log('ID');
                let id : Nullable<string>;
                let res : Nullable<ID> = null;
                if(true
                    && this.negate(() => this.matchKeyword($$dpth + 1, cr)) != null
                    && (id = this.regexAccept(String.raw`[a-zA-Z_áéíóúÁÉÍÓÚ]+`, $$dpth+1, cr)) != null
                )
                    res = {kind: ASTKinds.ID, id : id};
                return res;
            }, cr)();
    }
    matchINT($$dpth : number, cr? : ContextRecorder) : Nullable<INT> {
        return this.regexAccept(String.raw`[0-9]+`, $$dpth+1, cr);
    }
    match_($$dpth : number, cr? : ContextRecorder) : Nullable<_> {
        return this.regexAccept(String.raw`\s*`, $$dpth+1, cr);
    }
    parse() : ParseResult {
        const mrk = this.mark();
        const res = this.matchProgram(0);
        if(res && this.finished())
            return new ParseResult(res, null);
        this.reset(mrk);
        const rec = new ErrorTracker();
        this.matchProgram(0, rec);
        return new ParseResult(res, rec.getErr());
    }
}
export class ParseResult {
    ast : Nullable<Program>;
    err : Nullable<SyntaxErr>;
    constructor(ast : Nullable<Program>, err : Nullable<SyntaxErr>){
        this.ast = ast;
        this.err = err;
    }
}
export class PosInfo {
    overall_pos : number;
    line : number;
    offset : number;
    constructor(overall_pos : number, line : number, offset : number) {
        this.overall_pos = overall_pos;
        this.line = line;
        this.offset = offset;
    }
}
export class SyntaxErr {
    pos : PosInfo;
    exprules : string[];
    expmatches : string[]
    constructor(pos : PosInfo, exprules : Set<string>, expmatches : Set<string>){
        this.pos = pos;
        this.exprules = [...exprules];
        this.expmatches = [...expmatches];
    }
    toString() : string {
        return `Syntax Error at line ${this.pos.line}:${this.pos.offset}. Tried to match rules ${this.exprules.join(', ')}. Expected one of ${this.expmatches.map(x => ` '${x}'`)}`;
    }
}
class ErrorTracker implements ContextRecorder {
    mxpos : PosInfo = new PosInfo(-1, -1, -1)
    mnd : number = -1;
    prules : Set<string> = new Set();
    pmatches: Set<string> = new Set();
    record(pos : PosInfo, depth : number, result : any, negating : boolean, extraInfo : string[]){
        if((result === null) === negating)
            return;
        if(pos.overall_pos > this.mxpos.overall_pos){
            this.mxpos = pos;
            this.mnd = depth;
            this.pmatches.clear();
            this.prules.clear();
        } else if(pos.overall_pos === this.mxpos.overall_pos && depth < this.mnd){
            this.mnd = depth;
            this.prules.clear();
        }
        if(this.mxpos.overall_pos === pos.overall_pos && extraInfo.length >= 2) {
            if(extraInfo[0] === '$$StrMatch')
                this.pmatches.add(extraInfo[1]);
            if(extraInfo[0] === '$$!StrMatch')
                this.pmatches.add(`not ${extraInfo[1]}`);
        }
        if(this.mxpos.overall_pos === pos.overall_pos && this.mnd === depth)
            extraInfo.forEach(x => { if(x !== '$$StrMatch' && x !== '$$!StrMatch') this.prules.add(x)});
    }
    getErr() : SyntaxErr | null {
        if(this.mxpos.overall_pos !== -1)
            return new SyntaxErr(this.mxpos, this.prules, this.pmatches);
        return null;
    }
}